name: Extract App Icons

on:
  # Automatically run after Build Curated App List completes
  workflow_run:
    workflows: ["Build Curated App List"]
    types: [completed]
    branches: [main, master]
  schedule:
    # Run weekly on Saturdays at 04:00 UTC (fallback)
    - cron: '0 4 * * 6'
  workflow_dispatch:
    inputs:
      app_ids:
        description: 'Specific app IDs to extract icons for (comma-separated, or "all")'
        required: false
        default: 'all'
      max_apps:
        description: 'Maximum number of apps to process'
        required: false
        default: '100'
      force_refresh:
        description: 'Re-extract icons even if they exist'
        required: false
        default: 'false'
        type: boolean

# Prevent concurrent runs that could cause git conflicts
# Use same group as build-app-list and sync-manifests to ensure sequential execution
concurrency:
  group: curated-apps-pipeline
  cancel-in-progress: false

env:
  MAX_APPS: ${{ github.event.inputs.max_apps || '100' }}

permissions:
  contents: write

jobs:
  extract-icons:
    runs-on: windows-latest
    timeout-minutes: 180
    # Only run if triggered manually, by schedule, or if the upstream workflow succeeded
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install ImageMagick and 7-Zip
        run: |
          choco install imagemagick.app 7zip -y --no-progress
          refreshenv
          # Verify 7-Zip installation
          if (Test-Path "C:\Program Files\7-Zip\7z.exe") {
            Write-Host "7-Zip installed successfully"
          } else {
            Write-Host "7-Zip not found at expected path, checking alternatives..."
            Get-Command 7z -ErrorAction SilentlyContinue
          }
        shell: pwsh

      - name: Get apps to process
        id: get-apps
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          APP_IDS: ${{ github.event.inputs.app_ids || 'all' }}
          FORCE_REFRESH: ${{ github.event.inputs.force_refresh || 'false' }}
          MAX_APPS: ${{ env.MAX_APPS }}
        shell: bash
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const appIds = process.env.APP_IDS || 'all';
          const forceRefresh = process.env.FORCE_REFRESH === 'true';
          const maxApps = parseInt(process.env.MAX_APPS) || 100;

          if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            process.exit(1);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function getApps() {
            let query = supabase
              .from('curated_apps')
              .select('winget_id, name, publisher, latest_version');

            // Filter by specific app IDs if provided
            if (appIds !== 'all') {
              const targetIds = appIds.split(',').map(id => id.trim());
              query = query.in('winget_id', targetIds);
            }

            // Filter apps without icons (unless force refresh)
            if (!forceRefresh) {
              query = query.or('has_icon.is.null,has_icon.eq.false');
            }

            // Limit number of apps
            query = query.limit(maxApps);

            const { data: apps, error } = await query;

            if (error) {
              console.error('Failed to fetch apps:', error.message);
              process.exit(1);
            }

            // Batch-fetch known installer URLs from version_history
            const wingetIds = apps.map(a => a.winget_id);
            const installerUrlMap = {};
            if (wingetIds.length > 0) {
              const { data: vhRows } = await supabase
                .from('version_history')
                .select('winget_id, installer_url')
                .in('winget_id', wingetIds)
                .not('installer_url', 'is', null)
                .order('detected_at', { ascending: false });

              if (vhRows) {
                for (const row of vhRows) {
                  if (!installerUrlMap[row.winget_id]) {
                    installerUrlMap[row.winget_id] = row.installer_url;
                  }
                }
              }
              console.log(`Found ${Object.keys(installerUrlMap).length} cached installer URLs from version_history`);
            }

            // Additional local filtering for apps that don't have icon files
            const appsToProcess = [];
            for (const app of apps) {
              const iconPath = `public/icons/${app.winget_id}/icon-64.png`;
              if (forceRefresh || !fs.existsSync(iconPath)) {
                // Attach cached installer URL if available
                app.cached_installer_url = installerUrlMap[app.winget_id] || null;
                appsToProcess.push(app);
              }
              if (appsToProcess.length >= maxApps) break;
            }

            console.log(`Processing ${appsToProcess.length} apps for icon extraction`);

            // Save apps to process
            fs.writeFileSync('apps-to-process.json', JSON.stringify(appsToProcess, null, 2));

            // Output count for GitHub Actions
            const outputFile = process.env.GITHUB_OUTPUT;
            if (outputFile) {
              fs.appendFileSync(outputFile, `app_count=${appsToProcess.length}\n`);
            }
          }

          getApps().catch(err => {
            console.error('Error:', err);
            process.exit(1);
          });
          EOF

      - name: Extract icons
        if: steps.get-apps.outputs.app_count != '0'
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Continue'

          # Load apps to process
          $apps = Get-Content "apps-to-process.json" | ConvertFrom-Json

          $extracted = 0
          $failed = 0
          $results = @()

          foreach ($app in $apps) {
            $wingetId = $app.winget_id
            Write-Host "`n=== Processing $wingetId ===" -ForegroundColor Cyan

            try {
              # Create icon directory
              $iconDir = "public/icons/$wingetId"
              New-Item -ItemType Directory -Path $iconDir -Force | Out-Null

              # Get installer URL using three-tier fallback
              $installerUrl = $null
              $installerPath = $null

              $parts = $wingetId.Split('.')
              $publisher = $parts[0]
              $firstLetter = $publisher.Substring(0,1).ToLower()

              # Raw URLs: NO encoding (matches sync-manifests.yml pattern)
              $namePath = $parts[1..($parts.Length-1)] -join '/'
              $rawBaseUrl = "https://raw.githubusercontent.com/microsoft/winget-pkgs/master/manifests/$firstLetter/$publisher/$namePath"

              # API URLs: YES encoding (only used for version listing fallback)
              $encodedParts = $parts[1..($parts.Length-1)] | ForEach-Object { [uri]::EscapeDataString($_) }
              $encodedNamePath = $encodedParts -join '/'
              $encodedPublisher = [uri]::EscapeDataString($publisher)
              $apiBaseUrl = "https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/$firstLetter/$encodedPublisher/$encodedNamePath"

              # --- Tier 1: Use cached installer URL from version_history ---
              if ($app.cached_installer_url) {
                Write-Host "Tier 1: Using cached installer URL from version_history"
                $installerUrl = $app.cached_installer_url
              }

              # --- Tier 2: Use latest_version from curated_apps + raw URL (no API call) ---
              if (-not $installerUrl -and $app.latest_version) {
                try {
                  $latestVersion = $app.latest_version
                  Write-Host "Tier 2: Using latest_version '$latestVersion' with raw URL"
                  $installerYamlUrl = "$rawBaseUrl/$latestVersion/$wingetId.installer.yaml"
                  $yamlContent = Invoke-WebRequest -Uri $installerYamlUrl -UseBasicParsing -ErrorAction Stop

                  $lines = $yamlContent.Content -split "`n"
                  foreach ($line in $lines) {
                    if ($line -match 'InstallerUrl:\s*(.+)') {
                      $installerUrl = $matches[1].Trim()
                      break
                    }
                  }
                } catch {
                  Write-Host "Tier 2 failed for $wingetId : $($_.Exception.Message)"
                }
              }

              # --- Tier 3: Fall back to GitHub API version listing ---
              if (-not $installerUrl) {
                try {
                  Write-Host "Tier 3: Listing versions via GitHub API"
                  $versions = Invoke-RestMethod -Uri $apiBaseUrl -Headers @{ 'User-Agent' = 'IntuneGet' } -ErrorAction Stop
                  $versionDirs = $versions | Where-Object { $_.type -eq 'dir' -and $_.name -match '^\d' }
                  $latestVersion = ($versionDirs | Sort-Object { [version]($_.name -replace '[^\d.]', '.') } -Descending -ErrorAction SilentlyContinue | Select-Object -First 1).name
                  if (-not $latestVersion) {
                    $latestVersion = ($versionDirs | Sort-Object name -Descending | Select-Object -First 1).name
                  }

                  if ($latestVersion) {
                    $installerYamlUrl = "$rawBaseUrl/$latestVersion/$wingetId.installer.yaml"
                    $yamlContent = Invoke-WebRequest -Uri $installerYamlUrl -UseBasicParsing -ErrorAction Stop

                    $lines = $yamlContent.Content -split "`n"
                    foreach ($line in $lines) {
                      if ($line -match 'InstallerUrl:\s*(.+)') {
                        $installerUrl = $matches[1].Trim()
                        break
                      }
                    }
                  }
                } catch {
                  Write-Warning "Tier 3 failed for $wingetId : $_"
                }
              }

              if (-not $installerUrl) {
                Write-Warning "No installer URL found for $wingetId"
                $failed++
                continue
              }

              # Download installer
              $extension = if ($installerUrl -match '\.msi(\?|$)') { '.msi' }
                          elseif ($installerUrl -match '\.msixbundle(\?|$)') { '.msixbundle' }
                          elseif ($installerUrl -match '\.msix(\?|$)') { '.msix' }
                          elseif ($installerUrl -match '\.appx(\?|$)') { '.appx' }
                          else { '.exe' }

              $installerPath = "$env:TEMP\installer_$([System.IO.Path]::GetRandomFileName())$extension"

              Write-Host "Downloading installer from $installerUrl"
              Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath -UseBasicParsing -MaximumRedirection 5

              if (-not (Test-Path $installerPath)) {
                Write-Warning "Failed to download installer for $wingetId"
                $failed++
                continue
              }

              # Extract icon using PowerShell script (capture exit code, don't fail on error)
              $extractResult = & "$env:GITHUB_WORKSPACE\.github\scripts\extract-icon.ps1" `
                -InstallerPath $installerPath `
                -OutputDir $iconDir `
                -AppId $wingetId 2>&1
              $extractExitCode = $LASTEXITCODE

              if ($extractExitCode -ne 0) {
                Write-Host "Icon extraction script returned exit code: $extractExitCode"
                Write-Host $extractResult
              }

              # Check if icon was extracted
              if (Test-Path "$iconDir/icon-64.png") {
                Write-Host "Successfully extracted icon for $wingetId" -ForegroundColor Green
                $extracted++
                $results += @{
                  winget_id = $wingetId
                  status = 'success'
                  icon_path = "/icons/$wingetId/"
                }
              } else {
                Write-Warning "No icon extracted for $wingetId"
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = 'No icon extracted'
                }
              }
            } catch {
              Write-Warning "Error processing $wingetId : $_"
              $failed++
              $results += @{
                winget_id = $wingetId
                status = 'failed'
                error = $_.ToString()
              }
            } finally {
              # Cleanup
              if ($installerPath -and (Test-Path $installerPath)) {
                Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
              }
            }

            # Brief pause between apps
            Start-Sleep -Seconds 1
          }

          Write-Host "`n=== Icon Extraction Summary ===" -ForegroundColor Cyan
          Write-Host "Extracted: $extracted"
          Write-Host "Failed: $failed"

          # Save results
          $results | ConvertTo-Json -Depth 10 | Out-File "icon-results.json" -Encoding UTF8

          echo "extracted=$extracted" >> $env:GITHUB_OUTPUT
          echo "failed=$failed" >> $env:GITHUB_OUTPUT

          # Don't fail the workflow even if some icons failed to extract
          # This allows partial success and prevents blocking other steps
          exit 0

      - name: Commit icons
        id: commit-icons
        if: steps.get-apps.outputs.app_count != '0'
        shell: bash
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Stash extracted icons before switching branches
          # (workflow_run trigger causes detached HEAD, so checkout would fail with uncommitted changes)
          STASH_CREATED=false
          git add public/icons/ || true
          if ! git diff --staged --quiet 2>/dev/null; then
            git stash --include-untracked
            STASH_CREATED=true
          fi

          # Fetch latest and checkout main branch
          git fetch origin main
          git checkout main || git checkout -b main origin/main
          git pull origin main

          # Restore the extracted icons onto main (only if we actually stashed)
          if [ "$STASH_CREATED" = true ]; then
            git stash pop || true
          fi

          # Stage the new icons
          git add public/icons/ || true

          if git diff --staged --quiet; then
            echo "No new icons to commit"
            echo "committed=false" >> $GITHUB_OUTPUT
            echo "committed_apps=" >> $GITHUB_OUTPUT
          else
            # Get list of apps with committed icons (extract winget_id from path)
            COMMITTED_APPS=$(git diff --staged --name-only | grep "icon-64.png" | sed 's|public/icons/\(.*\)/icon-64.png|\1|' | tr '\n' ',' | sed 's/,$//')
            ICON_COUNT=$(echo "$COMMITTED_APPS" | tr ',' '\n' | grep -c . || echo "0")

            git commit -m "chore: add icons for $ICON_COUNT apps"

            # Push with retry for race conditions
            PUSH_SUCCESS=false
            for i in 1 2 3; do
              if git pull --rebase origin main && git push origin main; then
                PUSH_SUCCESS=true
                break
              fi
              echo "Retry $i: pull/push failed, retrying..."
              sleep 5
            done

            if [ "$PUSH_SUCCESS" = true ]; then
              echo "committed=true" >> $GITHUB_OUTPUT
              echo "committed_apps=$COMMITTED_APPS" >> $GITHUB_OUTPUT
              echo "Successfully committed icons for: $COMMITTED_APPS"
            else
              echo "committed=false" >> $GITHUB_OUTPUT
              echo "committed_apps=" >> $GITHUB_OUTPUT
              echo "Failed to push icons to repository"
            fi
          fi

      - name: Update database
        if: steps.commit-icons.outputs.committed == 'true'
        shell: bash
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          COMMITTED_APPS: ${{ steps.commit-icons.outputs.committed_apps }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const committedApps = process.env.COMMITTED_APPS ? process.env.COMMITTED_APPS.split(',').filter(Boolean) : [];

          if (!supabaseUrl || !supabaseKey) {
            console.log('Supabase credentials not configured, skipping database update');
            process.exit(0);
          }

          if (committedApps.length === 0) {
            console.log('No apps to update in database');
            process.exit(0);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function updateDatabase() {
            const results = JSON.parse(fs.readFileSync('icon-results.json', 'utf8'));

            // Only update apps that were actually committed
            const toUpdate = results.filter(r =>
              r.status === 'success' && committedApps.includes(r.winget_id)
            );

            console.log(`Updating database for ${toUpdate.length} committed apps`);

            for (const result of toUpdate) {
              const { error } = await supabase
                .from('curated_apps')
                .update({
                  icon_path: result.icon_path,
                  has_icon: true,
                  updated_at: new Date().toISOString()
                })
                .eq('winget_id', result.winget_id);

              if (error) {
                console.error(`Failed to update ${result.winget_id}:`, error.message);
              } else {
                console.log(`Updated ${result.winget_id}`);
              }
            }

            // Update sync status
            await supabase.from('curated_sync_status').upsert({
              id: 'extract-icons',
              last_run_completed_at: new Date().toISOString(),
              last_run_status: 'success',
              items_processed: toUpdate.length,
              metadata: {
                total: results.length,
                successful: toUpdate.length,
                failed: results.filter(r => r.status === 'failed').length
              },
              updated_at: new Date().toISOString()
            });

            console.log(`Updated ${toUpdate.length} apps with icon paths`);
          }

          updateDatabase()
            .then(() => {
              console.log('Database update complete');
              process.exit(0);
            })
            .catch(err => {
              console.error('Database update failed:', err);
              process.exit(1);
            });
          EOF

      - name: Create summary
        run: |
          if (Test-Path icon-results.json) {
            $results = Get-Content icon-results.json | ConvertFrom-Json
            $success = ($results | Where-Object { $_.status -eq 'success' }).Count
            $failed = ($results | Where-Object { $_.status -eq 'failed' }).Count

            @"
          ## Icon Extraction Summary

          - **Successfully extracted:** $success
          - **Failed:** $failed
          - **Total processed:** $($results.Count)

          ### Extracted Icons
          "@ | Out-File -Append $env:GITHUB_STEP_SUMMARY

            foreach ($r in ($results | Where-Object { $_.status -eq 'success' } | Select-Object -First 20)) {
              "- $($r.winget_id)" | Out-File -Append $env:GITHUB_STEP_SUMMARY
            }

            if ($failed -gt 0) {
              @"

          ### Failed Extractions
          "@ | Out-File -Append $env:GITHUB_STEP_SUMMARY

              foreach ($r in ($results | Where-Object { $_.status -eq 'failed' } | Select-Object -First 10)) {
                "- $($r.winget_id): $($r.error)" | Out-File -Append $env:GITHUB_STEP_SUMMARY
              }
            }
          }
        shell: pwsh

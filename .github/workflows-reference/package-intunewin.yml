name: Create and Deploy IntuneWin Package

on:
  repository_dispatch:
    types: [package-app]

jobs:
  package-and-deploy:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      # Map client_payload to environment variables for use in steps
      # Payload is grouped into: job, app, installer, config (GitHub limits to 10 top-level properties)
      JOB_ID: ${{ github.event.client_payload.job.jobId }}
      TENANT_ID: ${{ github.event.client_payload.job.tenantId }}
      CALLBACK_URL: ${{ github.event.client_payload.job.callbackUrl }}
      WINGET_ID: ${{ github.event.client_payload.app.wingetId }}
      DISPLAY_NAME: ${{ github.event.client_payload.app.displayName }}
      PUBLISHER: ${{ github.event.client_payload.app.publisher }}
      VERSION: ${{ github.event.client_payload.app.version }}
      ARCHITECTURE: ${{ github.event.client_payload.app.architecture }}
      INSTALLER_URL: ${{ github.event.client_payload.installer.url }}
      INSTALLER_SHA256: ${{ github.event.client_payload.installer.sha256 }}
      INSTALLER_TYPE: ${{ github.event.client_payload.installer.type }}
      SILENT_SWITCHES: ${{ github.event.client_payload.installer.silentSwitches }}
      UNINSTALL_COMMAND: ${{ github.event.client_payload.installer.uninstallCommand }}
      PSADT_CONFIG: ${{ github.event.client_payload.config.psadtConfig }}
      DETECTION_RULES: ${{ github.event.client_payload.config.detectionRules }}
      REQUIREMENT_RULES: ${{ github.event.client_payload.config.requirementRules }}
      ASSIGNMENTS: ${{ github.event.client_payload.config.assignments }}
      INSTALL_SCOPE: ${{ github.event.client_payload.config.installScope }}
      FORCE_CREATE: ${{ github.event.client_payload.config.forceCreate }}

    steps:
      - name: Checkout public repository for scripts
        uses: actions/checkout@v4
        with:
          repository: ugurkocde/IntuneGet
          path: intuneget

      - name: Setup callback helper function
        run: |
          # Define a reusable callback function with retry logic
          $callbackFunction = @'
          function Send-Callback {
            param(
              [Parameter(Mandatory=$true)]
              [hashtable]$Body,
              [Parameter(Mandatory=$true)]
              [string]$CallbackUrl,
              [Parameter(Mandatory=$true)]
              [string]$CallbackSecret,
              [int]$MaxRetries = 3,
              [int]$InitialDelaySeconds = 2
            )

            $json = $Body | ConvertTo-Json -Depth 5 -Compress
            $hmac = [System.Security.Cryptography.HMACSHA256]::new([System.Text.Encoding]::UTF8.GetBytes($CallbackSecret))
            $signature = [Convert]::ToBase64String($hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($json)))

            $headers = @{
              "Content-Type" = "application/json"
              "X-Signature" = $signature
            }

            $attempt = 0
            $success = $false
            $lastError = $null

            while (-not $success -and $attempt -lt $MaxRetries) {
              $attempt++
              try {
                $response = Invoke-RestMethod -Uri $CallbackUrl -Method POST -Headers $headers -Body $json -TimeoutSec 30
                $success = $true
                Write-Host "Callback sent successfully (attempt $attempt)"
                return $response
              } catch {
                $lastError = $_
                Write-Host "Callback failed (attempt $attempt/$MaxRetries): $($_.Exception.Message)"
                if ($attempt -lt $MaxRetries) {
                  $delay = $InitialDelaySeconds * [Math]::Pow(2, $attempt - 1)
                  Write-Host "Retrying in $delay seconds..."
                  Start-Sleep -Seconds $delay
                }
              }
            }

            if (-not $success) {
              Write-Warning "All callback attempts failed. Last error: $($lastError.Exception.Message)"
              # Don't throw - allow workflow to continue even if callback fails
            }
          }
          '@

          # Save the function to a file that can be dot-sourced in subsequent steps
          Set-Content -Path "$env:GITHUB_WORKSPACE\Send-Callback.ps1" -Value $callbackFunction
          Write-Host "Callback helper function created"

      - name: Check disk space
        run: |
          $drive = Get-Volume -DriveLetter C
          $freeGB = [math]::Round($drive.SizeRemaining / 1GB, 2)
          Write-Host "Free disk space: $freeGB GB"
          if ($freeGB -lt 10) {
            throw "Insufficient disk space: $freeGB GB available, need 10GB minimum"
          }

      - name: Send initial status callback
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          Write-Host "::add-mask::$env:TENANT_ID"
          Write-Host "========================================"
          Write-Host "Packaging: $env:DISPLAY_NAME v$env:VERSION"
          Write-Host "Publisher: $env:PUBLISHER"
          Write-Host "Winget ID: $env:WINGET_ID"
          Write-Host "========================================"

          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "packaging"
            message = "Starting packaging pipeline..."
            progress = 5
            runId = "${{ github.run_id }}"
            runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

      - name: Download tools
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "packaging"
            message = "Downloading packaging tools..."
            progress = 10
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          $toolsDir = ".\tools"
          New-Item -ItemType Directory -Path $toolsDir -Force
          Invoke-WebRequest -Uri "https://github.com/microsoft/Microsoft-Win32-Content-Prep-Tool/raw/master/IntuneWinAppUtil.exe" -OutFile "$toolsDir\IntuneWinAppUtil.exe"
          Invoke-WebRequest -Uri "https://github.com/PSAppDeployToolkit/PSAppDeployToolkit/releases/download/4.1.8/PSAppDeployToolkit_Template_v4.zip" -OutFile "psadt.zip"
          Expand-Archive -Path "psadt.zip" -DestinationPath ".\psadt"

      - name: Download and verify installer
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "packaging"
            message = "Downloading installer..."
            progress = 20
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          $installerDir = ".\installer"
          New-Item -ItemType Directory -Path $installerDir -Force

          $url = $env:INSTALLER_URL
          $fileName = [System.IO.Path]::GetFileName([System.Uri]::new($url).LocalPath)
          if ([string]::IsNullOrEmpty($fileName)) { $fileName = "installer.$env:INSTALLER_TYPE" }

          Invoke-WebRequest -Uri $url -OutFile "$installerDir\$fileName" -UseBasicParsing -AllowInsecureRedirect

          $expectedHash = $env:INSTALLER_SHA256
          if ($expectedHash -and $expectedHash -ne "") {
            $actualHash = (Get-FileHash "$installerDir\$fileName" -Algorithm SHA256).Hash
            if ($actualHash -ne $expectedHash) {
              throw "SHA256 mismatch! Expected: $expectedHash, Got: $actualHash"
            }
            Write-Host "SHA256 verified successfully"
          }

          echo "INSTALLER_PATH=$installerDir\$fileName" >> $env:GITHUB_ENV
          echo "INSTALLER_FILENAME=$fileName" >> $env:GITHUB_ENV

      - name: Create PSADT package
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
          INPUT_JOB_ID: ${{ github.event.client_payload.job.jobId }}
          INPUT_CALLBACK_URL: ${{ github.event.client_payload.job.callbackUrl }}
          INPUT_SILENT_SWITCHES: ${{ github.event.client_payload.installer.silentSwitches }}
          INPUT_UNINSTALL_COMMAND: ${{ github.event.client_payload.installer.uninstallCommand }}
          INPUT_DISPLAY_NAME: ${{ github.event.client_payload.app.displayName }}
          INPUT_PUBLISHER: ${{ github.event.client_payload.app.publisher }}
          INPUT_VERSION: ${{ github.event.client_payload.app.version }}
          INPUT_WINGET_ID: ${{ github.event.client_payload.app.wingetId }}
          INPUT_INSTALLER_TYPE: ${{ github.event.client_payload.installer.type }}
          INPUT_INSTALL_SCOPE: ${{ github.event.client_payload.config.installScope }}
          INPUT_ARCHITECTURE: ${{ github.event.client_payload.app.architecture }}
        run: |
          & "$env:GITHUB_WORKSPACE\intuneget\.github\scripts\Create-PSADTPackage.ps1"

      - name: Create IntuneWin package
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "packaging"
            message = "Creating .intunewin package..."
            progress = 50
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          $outputDir = ".\output"
          New-Item -ItemType Directory -Path $outputDir -Force

          & .\tools\IntuneWinAppUtil.exe -c ".\package" -s "Invoke-AppDeployToolkit.exe" -o $outputDir -q

          $intunewinFile = Get-ChildItem $outputDir -Filter "*.intunewin" | Select-Object -First 1
          if (-not $intunewinFile) {
            throw "IntuneWin package was not created"
          }

          # Rename package to use display name for better identification in Intune
          $displayName = $env:DISPLAY_NAME
          $safeDisplayName = $displayName -replace '[\\/:*?"<>|]', '_'
          $packageFileName = "$safeDisplayName.intunewin"
          $newPath = Join-Path $outputDir $packageFileName

          if ($intunewinFile.Name -ne $packageFileName) {
            Move-Item $intunewinFile.FullName $newPath -Force
            $intunewinFile = Get-Item $newPath
          }

          echo "INTUNEWIN_PATH=$($intunewinFile.FullName)" >> $env:GITHUB_ENV
          echo "INTUNEWIN_SIZE=$($intunewinFile.Length)" >> $env:GITHUB_ENV
          echo "PACKAGE_FILENAME=$packageFileName" >> $env:GITHUB_ENV
          Write-Host "Created package: $($intunewinFile.Name) ($([math]::Round($intunewinFile.Length/1MB, 2)) MB)"

      - name: Extract encryption info and encrypted content file
        run: |
          $tempDir = ".\intunewin-extract"
          Expand-Archive -Path "$env:INTUNEWIN_PATH" -DestinationPath $tempDir -Force

          $detectionXml = Get-ChildItem $tempDir -Filter "Detection.xml" -Recurse | Select-Object -First 1
          if ($detectionXml) {
            [xml]$xml = Get-Content $detectionXml.FullName
            $encInfo = @{
              encryptionKey = $xml.ApplicationInfo.EncryptionInfo.EncryptionKey
              macKey = $xml.ApplicationInfo.EncryptionInfo.macKey
              initializationVector = $xml.ApplicationInfo.EncryptionInfo.initializationVector
              mac = $xml.ApplicationInfo.EncryptionInfo.mac
              profileIdentifier = "ProfileVersion1"
              fileDigest = $xml.ApplicationInfo.EncryptionInfo.fileDigest
              fileDigestAlgorithm = $xml.ApplicationInfo.EncryptionInfo.fileDigestAlgorithm
            }
            $encJson = $encInfo | ConvertTo-Json -Compress
            echo "ENCRYPTION_INFO=$encJson" >> $env:GITHUB_ENV
            echo "UNENCRYPTED_SIZE=$($xml.ApplicationInfo.UnencryptedContentSize)" >> $env:GITHUB_ENV

            # Extract the encrypted content file name from metadata
            $encryptedFileName = $xml.ApplicationInfo.FileName
            Write-Host "Encrypted content file name from metadata: $encryptedFileName"

            # Find the encrypted content file in the extracted archive
            $encryptedFile = Get-ChildItem $tempDir -Filter $encryptedFileName -Recurse | Select-Object -First 1
            if ($encryptedFile) {
              $encryptedFilePath = $encryptedFile.FullName
              $encryptedFileSize = $encryptedFile.Length
              Write-Host "Found encrypted file: $encryptedFilePath ($([math]::Round($encryptedFileSize/1MB, 2)) MB)"
              echo "ENCRYPTED_FILE_PATH=$encryptedFilePath" >> $env:GITHUB_ENV
              echo "ENCRYPTED_FILE_SIZE=$encryptedFileSize" >> $env:GITHUB_ENV
            } else {
              Write-Host "WARNING: Could not find encrypted file '$encryptedFileName', falling back to .intunewin"
              echo "ENCRYPTED_FILE_PATH=$env:INTUNEWIN_PATH" >> $env:GITHUB_ENV
              echo "ENCRYPTED_FILE_SIZE=$env:INTUNEWIN_SIZE" >> $env:GITHUB_ENV
            }
          }

      - name: Test package installation
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"

          try {
            $env:INPUT_PACKAGE_DIR = ".\package"
            $env:INPUT_DETECTION_RULES = $env:DETECTION_RULES
            $env:INPUT_WINGET_ID = $env:WINGET_ID
            $env:INPUT_VERSION = $env:VERSION
            $env:INPUT_INSTALL_SCOPE = $env:INSTALL_SCOPE
            $env:INPUT_INSTALLER_TYPE = $env:INSTALLER_TYPE
            $env:INPUT_TIMEOUT_SECONDS = "300"

            & "$env:GITHUB_WORKSPACE\.github\scripts\Test-PSADTPackage.ps1"

            $results = Get-Content ".\test-results.json" | ConvertFrom-Json
            if (-not $results.passed) {
              $failMsg = "Package test failed: $($results.failureReason)"
              Send-Callback -Body @{
                jobId = $env:JOB_ID
                status = "failed"
                message = $failMsg
                progress = 0
                errorStage = "test"
                errorCategory = "validation"
                errorCode = $results.failureReason
                errorDetails = @{
                  testResults = $results
                  displayName = $env:DISPLAY_NAME
                  version = $env:VERSION
                }
              } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null
              $env:ERROR_SENT = "true"
              throw $failMsg
            }

            Send-Callback -Body @{
              jobId    = $env:JOB_ID
              status   = "testing"
              message  = "Package test passed"
              progress = 62
            } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

            Write-Host "Package test passed in $($results.totalDuration_ms)ms"

          } catch {
            if ($env:ERROR_SENT -ne "true") {
              Send-Callback -Body @{
                jobId = $env:JOB_ID
                status = "failed"
                message = "Package test error: $($_.Exception.Message)"
                progress = 0
                errorStage = "test"
                errorCategory = "validation"
                errorCode = "PACKAGE_TEST_ERROR"
                errorDetails = @{ error = $_.Exception.Message }
              } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null
            }
            throw
          }

      - name: Upload test debug logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-debug-logs
          path: |
            test-debug.log
            test-results.json
          retention-days: 7
          if-no-files-found: ignore

      - name: Clean up temp files
        run: |
          Remove-Item -Path ".\installer" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path ".\psadt" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path ".\package" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path ".\test-results.json" -Force -ErrorAction SilentlyContinue
          Remove-Item -Path ".\test-debug.log" -Force -ErrorAction SilentlyContinue

      - name: Authenticate to Microsoft Graph
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        run: |
          $tenantId = $env:TENANT_ID
          Write-Host "::add-mask::$tenantId"
          $body = @{
            client_id = $env:AZURE_CLIENT_ID
            client_secret = $env:AZURE_CLIENT_SECRET
            scope = "https://graph.microsoft.com/.default"
            grant_type = "client_credentials"
          }

          $tokenResponse = Invoke-RestMethod -Uri "https://login.microsoftonline.com/$tenantId/oauth2/v2.0/token" -Method POST -Body $body -ContentType "application/x-www-form-urlencoded"

          $token = $tokenResponse.access_token
          Write-Host "::add-mask::$token"
          echo "GRAPH_TOKEN=$token" >> $env:GITHUB_ENV

      - name: Check for duplicate app in Intune
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
          INPUT_DISPLAY_NAME: ${{ github.event.client_payload.app.displayName }}
          INPUT_WINGET_ID: ${{ github.event.client_payload.app.wingetId }}
          INPUT_FORCE_CREATE: ${{ github.event.client_payload.config.forceCreate }}
          INPUT_JOB_ID: ${{ github.event.client_payload.job.jobId }}
          INPUT_CALLBACK_URL: ${{ github.event.client_payload.job.callbackUrl }}
        run: |
          & "$env:GITHUB_WORKSPACE\intuneget\.github\scripts\Check-DuplicateApp.ps1"

      - name: Upload to Intune
        if: env.DUPLICATE_FOUND != 'true'
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "uploading"
            message = "Uploading to Microsoft Intune..."
            progress = 70
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          $headers = @{
            "Authorization" = "Bearer $env:GRAPH_TOKEN"
            "Content-Type" = "application/json"
          }

          # Parse PSADT config for restart behavior
          $restartBehavior = "suppress"  # Default
          if ($env:PSADT_CONFIG -and $env:PSADT_CONFIG -ne '{}') {
            try {
              $psadtConfig = $env:PSADT_CONFIG | ConvertFrom-Json -AsHashtable
              if ($psadtConfig.restartBehavior) {
                # Map frontend values to Intune API values
                $restartBehavior = switch ($psadtConfig.restartBehavior) {
                  'Suppress' { 'suppress' }
                  'Force' { 'force' }
                  'Prompt' { 'basedOnReturnCode' }
                  'Defer' { 'basedOnReturnCode' }
                  default { 'suppress' }
                }
                Write-Host "Restart behavior set to: $restartBehavior"
              }
            } catch {
              Write-Host "Warning: Could not parse PSADT config for restart behavior, using default"
            }
          }

          $inputArchitecture = ($env:ARCHITECTURE ?? '').ToLowerInvariant()
          $mappedApplicableArchitecture = 'x64'
          $mappedAllowedArchitecture = $null

          switch ($inputArchitecture) {
            'x86' { $mappedApplicableArchitecture = 'x86' }
            'x64' { $mappedApplicableArchitecture = 'x64' }
            'arm64' {
              # Use modern field for ARM64 targeting; Graph sets applicableArchitectures to none.
              $mappedApplicableArchitecture = 'none'
              $mappedAllowedArchitecture = 'arm64'
            }
            'arm' {
              Write-Host "Architecture 'arm' is not supported for Intune Win32 app targeting; using 'x64'"
              $mappedApplicableArchitecture = 'x64'
            }
            'neutral' {
              Write-Host "Architecture 'neutral' is not supported for Intune Win32 app targeting; using 'x64'"
              $mappedApplicableArchitecture = 'x64'
            }
            default {
              if ($inputArchitecture) {
                Write-Host "Architecture '$inputArchitecture' is not recognized; using 'x64'"
              }
              $mappedApplicableArchitecture = 'x64'
            }
          }

          # Parse and convert detection rules to Graph API format
          $graphRules = @()
          $detectionRulesJson = $env:DETECTION_RULES
          if ($detectionRulesJson -and $detectionRulesJson -ne '[]') {
            try {
              $rules = $detectionRulesJson | ConvertFrom-Json
              foreach ($rule in $rules) {
                $graphRule = $null
                switch ($rule.type) {
                  'file' {
                    $graphRule = @{
                      '@odata.type' = '#microsoft.graph.win32LobAppFileSystemRule'
                      ruleType = 'detection'
                      path = $rule.path
                      fileOrFolderName = $rule.fileOrFolderName
                      check32BitOn64System = if ($rule.check32BitOn64System) { $true } else { $false }
                      operationType = switch ($rule.detectionType) {
                        'exists' { 'exists' }
                        'notExists' { 'notExists' }
                        'version' { 'version' }
                        'dateModified' { 'modifiedDate' }
                        'dateCreated' { 'createdDate' }
                        'string' { 'string' }
                        'sizeInMB' { 'sizeInMB' }
                        default { 'exists' }
                      }
                      operator = if ($rule.operator) { $rule.operator } else { 'notConfigured' }
                      comparisonValue = $rule.detectionValue
                    }
                  }
                  'registry' {
                    $graphRule = @{
                      '@odata.type' = '#microsoft.graph.win32LobAppRegistryRule'
                      ruleType = 'detection'
                      keyPath = $rule.keyPath
                      valueName = $rule.valueName
                      check32BitOn64System = if ($rule.check32BitOn64System) { $true } else { $false }
                      operationType = switch ($rule.detectionType) {
                        'exists' { 'exists' }
                        'notExists' { 'notExists' }
                        'string' { 'string' }
                        'integer' { 'integer' }
                        'version' { 'version' }
                        default { 'exists' }
                      }
                      operator = if ($rule.operator) { $rule.operator } else { 'notConfigured' }
                      comparisonValue = $rule.detectionValue
                    }
                  }
                  'msi' {
                    $graphRule = @{
                      '@odata.type' = '#microsoft.graph.win32LobAppProductCodeRule'
                      ruleType = 'detection'
                      productCode = $rule.productCode
                      productVersionOperator = if ($rule.productVersionOperator) { $rule.productVersionOperator } else { 'notConfigured' }
                      productVersion = $rule.productVersion
                    }
                  }
                  'script' {
                    $graphRule = @{
                      '@odata.type' = '#microsoft.graph.win32LobAppPowerShellScriptRule'
                      ruleType = 'detection'
                      scriptContent = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($rule.scriptContent))
                      enforceSignatureCheck = if ($rule.enforceSignatureCheck) { $true } else { $false }
                      runAs32Bit = if ($rule.runAs32Bit) { $true } else { $false }
                      displayName = 'Detection Script'
                    }
                  }
                }
                if ($graphRule) {
                  $graphRules += $graphRule
                }
              }
            } catch {
              Write-Host "Warning: Could not parse detection rules: $_"
            }
          }

          # If no detection rules provided, create a default script-based detection
          if ($graphRules.Count -eq 0) {
            Write-Host "No detection rules provided, using default registry-based detection script"
            $displayName = $env:DISPLAY_NAME
            $wingetId = $env:WINGET_ID
            $scriptLines = @(
              "# Auto-generated detection script for $displayName"
              "`$ErrorActionPreference = 'SilentlyContinue'"
              "`$AppName = `"$displayName`""
              "`$WingetId = `"$wingetId`""
              "`$SanitizedWingetId = `$WingetId -replace '[\.\-]', '_'"
              ""
              "# Check 1: IntuneGet registry marker (HKLM for machine-scope, HKCU for user-scope)"
              "`$intuneGetPaths = @("
              "    `"HKLM:\SOFTWARE\IntuneGet\Apps\`$SanitizedWingetId`","
              "    `"HKCU:\SOFTWARE\IntuneGet\Apps\`$SanitizedWingetId`""
              ")"
              "foreach (`$intuneGetPath in `$intuneGetPaths) {"
              "    if (Test-Path `$intuneGetPath) {"
              "        `$marker = Get-ItemProperty `$intuneGetPath -ErrorAction SilentlyContinue"
              "        if (`$marker.DisplayName) {"
              "            Write-Output `"Detected via IntuneGet marker: `$(`$marker.DisplayName) v`$(`$marker.Version)`""
              "            exit 0"
              "        }"
              "    }"
              "}"
              ""
              "# Check 2: Traditional uninstall registry (HKLM for machine-scope, HKCU for user-scope)"
              "`$uninstallPaths = @("
              "    `"HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*`","
              "    `"HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*`","
              "    `"HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*`""
              ")"
              ""
              "foreach (`$path in `$uninstallPaths) {"
              "    `$apps = Get-ItemProperty `$path -ErrorAction SilentlyContinue |"
              "        Where-Object { `$_.DisplayName -like `"*`$AppName*`" }"
              "    if (`$apps) {"
              "        Write-Output `"Detected: `$(`$apps[0].DisplayName)`""
              "        exit 0"
              "    }"
              "}"
              ""
              "exit 1"
            )
            $detectionScript = $scriptLines -join "`r`n"
            $graphRules = @(
              @{
                '@odata.type' = '#microsoft.graph.win32LobAppPowerShellScriptRule'
                ruleType = 'detection'
                scriptContent = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($detectionScript))
                enforceSignatureCheck = $false
                runAs32Bit = $false
                displayName = 'Detection Script'
              }
            )
          }

          # Parse and merge requirement rules (already in Graph API format with ruleType: 'requirement')
          $requirementRulesJson = $env:REQUIREMENT_RULES
          if ($requirementRulesJson -and $requirementRulesJson -ne '[]') {
            try {
              $reqRules = $requirementRulesJson | ConvertFrom-Json -AsHashtable
              foreach ($reqRule in $reqRules) {
                $graphRules += $reqRule
              }
              Write-Host "Added $($reqRules.Count) requirement rule(s) for Update Only mode"
            } catch {
              Write-Host "Warning: Could not parse requirement rules: $_"
            }
          }

          Write-Host "Detection rules configured: $($graphRules.Count) rule(s)"

          # Load app icon if available
          $largeIcon = $null
          $iconPath = "intuneget/icons/$env:WINGET_ID/icon-128.png"
          if (Test-Path $iconPath) {
            $iconBytes = [System.IO.File]::ReadAllBytes($iconPath)
            $iconBase64 = [System.Convert]::ToBase64String($iconBytes)
            $largeIcon = @{
              type = "image/png"
              value = $iconBase64
            }
            Write-Host "Loaded app icon from $iconPath"
          } else {
            Write-Host "No icon found at $iconPath, deploying without icon"
          }

          # 1. Create the Win32 app in Intune
          $appBodyHash = @{
            "@odata.type" = "#microsoft.graph.win32LobApp"
            displayName = $env:DISPLAY_NAME
            publisher = $env:PUBLISHER
            description = "Deployed via IntuneGet from Winget: $env:WINGET_ID"
            largeIcon = $largeIcon
            fileName = "$env:PACKAGE_FILENAME"
            installCommandLine = "Invoke-AppDeployToolkit.exe"
            uninstallCommandLine = "Invoke-AppDeployToolkit.exe -DeploymentType Uninstall"
            applicableArchitectures = $mappedApplicableArchitecture
            installExperience = @{
              runAsAccount = if ($env:INSTALL_SCOPE -eq "user") { "user" } else { "system" }
              deviceRestartBehavior = $restartBehavior
            }
            returnCodes = @(
              @{ returnCode = 0; type = "success" }
              @{ returnCode = 1707; type = "success" }
              @{ returnCode = 3010; type = "softReboot" }
              @{ returnCode = 1641; type = "hardReboot" }
              @{ returnCode = 1618; type = "retry" }
              @{ returnCode = 60012; type = "retry" }  # No user logged in - retry later for per-user installs
            )
            rules = $graphRules
            msiInformation = $null
            setupFilePath = "Invoke-AppDeployToolkit.exe"
            minimumSupportedWindowsRelease = "1903"
          }

          if ($mappedAllowedArchitecture) {
            $appBodyHash.allowedArchitectures = $mappedAllowedArchitecture
          }

          $appBody = $appBodyHash | ConvertTo-Json -Depth 10

          $app = Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps" -Method POST -Headers $headers -Body $appBody
          $appId = $app.id
          Write-Host "Created Intune app: $appId"
          echo "INTUNE_APP_ID=$appId" >> $env:GITHUB_ENV

          # 2. Create content version
          $contentVersion = Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId/microsoft.graph.win32LobApp/contentVersions" -Method POST -Headers $headers -Body "{}"
          $contentVersionId = $contentVersion.id

          # 3. Create file entry - use the extracted encrypted file size
          $encryptedFileSize = [long]$env:ENCRYPTED_FILE_SIZE
          $unencryptedSize = [long]$env:UNENCRYPTED_SIZE
          $encInfo = $env:ENCRYPTION_INFO | ConvertFrom-Json

          Write-Host "Creating file entry: size=$unencryptedSize, sizeEncrypted=$encryptedFileSize"

          $fileBody = @{
            "@odata.type" = "#microsoft.graph.mobileAppContentFile"
            name = "$env:PACKAGE_FILENAME"
            size = $unencryptedSize
            sizeEncrypted = $encryptedFileSize
            manifest = $null
            isDependency = $false
          } | ConvertTo-Json

          $file = Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId/microsoft.graph.win32LobApp/contentVersions/$contentVersionId/files" -Method POST -Headers $headers -Body $fileBody
          $fileId = $file.id

          # 4. Wait for Azure Storage URI
          $maxWait = 60
          $waited = 0
          do {
            Start-Sleep -Seconds 2
            $waited += 2
            $fileStatus = Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId/microsoft.graph.win32LobApp/contentVersions/$contentVersionId/files/$fileId" -Headers $headers
          } while ($fileStatus.uploadState -eq "azureStorageUriRequestPending" -and $waited -lt $maxWait)

          if ($fileStatus.uploadState -ne "azureStorageUriRequestSuccess") {
            throw "Failed to get Azure Storage URI. State: $($fileStatus.uploadState)"
          }

          $azureStorageUri = $fileStatus.azureStorageUri
          Write-Host "Got Azure Storage URI for upload"

          # Send progress update
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "uploading"
            message = "Uploading package content..."
            progress = 80
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          # 5. Upload encrypted content file in parallel chunks (25MB blocks, 4 concurrent)
          # Uses .NET HttpClient with ByteArrayContent for true async I/O and zero-copy uploads
          $chunkSize = 25MB
          $concurrency = 4
          $uploadFilePath = $env:ENCRYPTED_FILE_PATH
          $fileSize = (Get-Item $uploadFilePath).Length
          $totalChunks = [Math]::Ceiling($fileSize / $chunkSize)
          Write-Host "Uploading file: $uploadFilePath"
          Write-Host "Upload strategy: $totalChunks chunks x 25MB, ${concurrency}x parallel"

          # Pre-compute all block IDs upfront for the final commit
          $blockIds = @()
          for ($i = 0; $i -lt $totalChunks; $i++) {
            $blockIds += [System.Convert]::ToBase64String(
              [System.Text.Encoding]::ASCII.GetBytes($i.ToString("0000"))
            )
          }

          # Create HttpClient with connection pooling for parallel uploads
          $handler = [System.Net.Http.SocketsHttpHandler]::new()
          $handler.MaxConnectionsPerServer = $concurrency
          $handler.PooledConnectionLifetime = [TimeSpan]::FromMinutes(10)
          $httpClient = [System.Net.Http.HttpClient]::new($handler)
          $httpClient.Timeout = [TimeSpan]::FromMinutes(30)

          # Pre-allocate reusable byte buffers (one per concurrent slot)
          $buffers = @()
          for ($i = 0; $i -lt $concurrency; $i++) {
            $buffers += (, (New-Object byte[] $chunkSize))
          }

          $fileStream = [System.IO.File]::OpenRead($uploadFilePath)
          $chunkIndex = 0
          $batchCount = 0

          while ($chunkIndex -lt $totalChunks) {
            $batchSize = [Math]::Min($concurrency, $totalChunks - $chunkIndex)
            $batchCount++

            $tasks = @()
            $requests = @()
            for ($slot = 0; $slot -lt $batchSize; $slot++) {
              $bytesRead = $fileStream.Read($buffers[$slot], 0, $chunkSize)

              $blockId = $blockIds[$chunkIndex + $slot]
              $blockUri = "$azureStorageUri&comp=block&blockid=$([System.Uri]::EscapeDataString($blockId))"

              $content = [System.Net.Http.ByteArrayContent]::new($buffers[$slot], 0, $bytesRead)
              $content.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::new("application/octet-stream")

              $request = [System.Net.Http.HttpRequestMessage]::new([System.Net.Http.HttpMethod]::Put, $blockUri)
              [void]$request.Headers.TryAddWithoutValidation("x-ms-blob-type", "BlockBlob")
              $request.Content = $content

              $requests += $request
              $tasks += $httpClient.SendAsync($request)
            }

            [System.Threading.Tasks.Task]::WaitAll($tasks)

            for ($slot = 0; $slot -lt $batchSize; $slot++) {
              $response = $tasks[$slot].Result
              if ([int]$response.StatusCode -ge 300) {
                $errBody = $response.Content.ReadAsStringAsync().Result
                $response.Dispose()
                $requests[$slot].Dispose()
                throw "Chunk $($chunkIndex + $slot) failed: HTTP $([int]$response.StatusCode) - $errBody"
              }
              $response.Dispose()
              $requests[$slot].Dispose()
            }

            if ($batchCount % 4 -eq 0 -or ($chunkIndex + $batchSize) -ge $totalChunks) {
              $uploadedChunks = $chunkIndex + $batchSize
              Write-Host "Upload progress: $uploadedChunks/$totalChunks chunks"
            }

            $chunkIndex += $batchSize
          }

          $fileStream.Close()
          Write-Host "Upload complete: $totalChunks chunks uploaded"

          # 6. Commit blocks to Azure Storage
          $blockListXml = '<?xml version="1.0" encoding="utf-8"?><BlockList>'
          foreach ($id in $blockIds) {
            $blockListXml += "<Latest>$id</Latest>"
          }
          $blockListXml += '</BlockList>'

          $commitUri = "$azureStorageUri&comp=blocklist"
          $commitContent = [System.Net.Http.StringContent]::new($blockListXml, [System.Text.Encoding]::UTF8, "text/plain")
          $commitResp = $httpClient.PutAsync($commitUri, $commitContent).Result
          if ([int]$commitResp.StatusCode -ge 300) {
            $commitErr = $commitResp.Content.ReadAsStringAsync().Result
            $commitResp.Dispose()
            throw "Block list commit failed: HTTP $([int]$commitResp.StatusCode) - $commitErr"
          }
          $commitResp.Dispose()
          $httpClient.Dispose()
          Write-Host "Block list committed to Azure Storage"

          # 7. Commit file with encryption info
          $commitBody = @{
            fileEncryptionInfo = @{
              encryptionKey = $encInfo.encryptionKey
              macKey = $encInfo.macKey
              initializationVector = $encInfo.initializationVector
              mac = $encInfo.mac
              profileIdentifier = $encInfo.profileIdentifier
              fileDigest = $encInfo.fileDigest
              fileDigestAlgorithm = $encInfo.fileDigestAlgorithm
            }
          } | ConvertTo-Json -Depth 5

          Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId/microsoft.graph.win32LobApp/contentVersions/$contentVersionId/files/$fileId/commit" -Method POST -Headers $headers -Body $commitBody

          # 8. Wait for commit to complete
          $maxWait = 120
          $waited = 0
          do {
            Start-Sleep -Seconds 3
            $waited += 3
            $fileStatus = Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId/microsoft.graph.win32LobApp/contentVersions/$contentVersionId/files/$fileId" -Headers $headers
          } while ($fileStatus.uploadState -eq "commitFilePending" -and $waited -lt $maxWait)

          if ($fileStatus.uploadState -ne "commitFileSuccess") {
            throw "File commit failed. State: $($fileStatus.uploadState)"
          }

          # 9. Update app with committed content version
          $updateBody = @{
            "@odata.type" = "#microsoft.graph.win32LobApp"
            committedContentVersion = $contentVersionId
          } | ConvertTo-Json

          Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appId" -Method PATCH -Headers $headers -Body $updateBody

          $intuneUrl = "https://intune.microsoft.com/#view/Microsoft_Intune_Apps/SettingsMenu/~/0/appId/$appId"
          echo "INTUNE_APP_URL=$intuneUrl" >> $env:GITHUB_ENV

          Write-Host "========================================"
          Write-Host "SUCCESS: Package deployed to Intune"
          Write-Host "App ID: $appId"
          Write-Host "URL: $intuneUrl"
          Write-Host "========================================"

      - name: Apply assignments
        if: success() && env.DUPLICATE_FOUND != 'true'
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          $assignmentsJson = $env:ASSIGNMENTS
          if (-not $assignmentsJson -or $assignmentsJson -eq '[]') {
            Write-Host "No assignments configured, skipping..."
            exit 0
          }

          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "uploading"
            message = "Applying assignments..."
            progress = 90
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET | Out-Null

          $headers = @{
            "Authorization" = "Bearer $env:GRAPH_TOKEN"
            "Content-Type" = "application/json"
          }

          $assignments = $assignmentsJson | ConvertFrom-Json
          $graphAssignments = @()

          foreach ($assignment in $assignments) {
            $target = switch ($assignment.type) {
              'allUsers' {
                @{ '@odata.type' = '#microsoft.graph.allLicensedUsersAssignmentTarget' }
              }
              'allDevices' {
                @{ '@odata.type' = '#microsoft.graph.allDevicesAssignmentTarget' }
              }
              'group' {
                @{
                  '@odata.type' = '#microsoft.graph.groupAssignmentTarget'
                  groupId = $assignment.groupId
                }
              }
            }

            # Map 'updateOnly' to 'required' for Graph API (requirement rules handle the gating)
            $graphIntent = if ($assignment.intent -eq 'updateOnly') { 'required' } else { $assignment.intent }

            $graphAssignments += @{
              '@odata.type' = '#microsoft.graph.mobileAppAssignment'
              intent = $graphIntent
              target = $target
              settings = @{
                '@odata.type' = '#microsoft.graph.win32LobAppAssignmentSettings'
                notifications = 'showAll'
                deliveryOptimizationPriority = 'notConfigured'
              }
            }
          }

          $body = @{
            mobileAppAssignments = $graphAssignments
          } | ConvertTo-Json -Depth 10

          Invoke-RestMethod -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$env:INTUNE_APP_ID/assign" -Method POST -Headers $headers -Body $body
          Write-Host "Applied $($graphAssignments.Count) assignment(s) to app"

      - name: Send success callback
        if: success() && env.DUPLICATE_FOUND != 'true'
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "deployed"
            message = "Successfully deployed to Intune"
            progress = 100
            intuneAppId = "$env:INTUNE_APP_ID"
            intuneAppUrl = "$env:INTUNE_APP_URL"
            runId = "${{ github.run_id }}"
            runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET -MaxRetries 5 | Out-Null

          # Write GitHub Job Summary
          $packageSizeMB = [math]::Round([long]$env:INTUNEWIN_SIZE / 1MB, 2)
          $summary = @(
            "## Intune Package Deployed",
            "",
            "| Property | Value |",
            "|----------|-------|",
            "| **App Name** | $env:DISPLAY_NAME |",
            "| **Version** | $env:VERSION |",
            "| **Publisher** | $env:PUBLISHER |",
            "| **Package ID** | $env:WINGET_ID |",
            "| **Intune App ID** | $env:INTUNE_APP_ID |",
            "| **Package Size** | $packageSizeMB MB |",
            "",
            "[View in Intune]($env:INTUNE_APP_URL)"
          ) -join "`n"
          $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append

      - name: Send failure callback
        if: failure() && env.DUPLICATE_FOUND != 'true'
        env:
          CALLBACK_SECRET: ${{ secrets.CALLBACK_SECRET }}
        run: |
          . "$env:GITHUB_WORKSPACE\Send-Callback.ps1"
          Send-Callback -Body @{
            jobId = $env:JOB_ID
            status = "failed"
            message = "Pipeline failed - check run logs"
            progress = 0
            runId = "${{ github.run_id }}"
            runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          } -CallbackUrl $env:CALLBACK_URL -CallbackSecret $env:CALLBACK_SECRET -MaxRetries 5 | Out-Null

          # Write GitHub Job Summary for failure
          $summary = @(
            "## Intune Package Deployment Failed",
            "",
            "| Property | Value |",
            "|----------|-------|",
            "| **App Name** | $env:DISPLAY_NAME |",
            "| **Version** | $env:VERSION |",
            "| **Publisher** | $env:PUBLISHER |",
            "| **Package ID** | $env:WINGET_ID |",
            "| **Status** | Failed |",
            "",
            "Check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details."
          ) -join "`n"
          $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append

name: Sync Winget Manifests

on:
  # Automatically run after Build Curated App List completes
  workflow_run:
    workflows: ["Build Curated App List"]
    types: [completed]
    branches: [main, master]
  schedule:
    # Run daily at 02:00 UTC
    - cron: "0 2 * * *"
  workflow_dispatch:
    inputs:
      app_ids:
        description: 'Specific app IDs to sync (comma-separated, or "all")'
        required: false
        default: "all"
      limit:
        description: "Maximum number of apps to process (0 = all)"
        required: false
        default: "2000"
        type: string
      mode:
        description: "Sync mode"
        required: false
        default: "incremental"
        type: choice
        options:
          - incremental # Only apps missing version data
          - new_only # Only apps without any version_history
          - all # All apps (full refresh)
      force_refresh:
        description: "Force refresh even if version unchanged"
        required: false
        default: false
        type: boolean

# Prevent concurrent runs
concurrency:
  group: curated-apps-pipeline
  cancel-in-progress: false

env:
  NODE_VERSION: "20"
  GITHUB_RAW_BASE: "https://raw.githubusercontent.com/microsoft/winget-pkgs/master/manifests"
  APP_LIMIT: ${{ github.event.inputs.limit || '2000' }}

jobs:
  sync-manifests:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    # Only run if triggered manually, by schedule, or if the upstream workflow succeeded
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch the latest commit (important when triggered by workflow_run)
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Sync manifests
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          APP_IDS: ${{ github.event.inputs.app_ids || 'all' }}
          APP_LIMIT: ${{ github.event.inputs.limit || '2000' }}
          SYNC_MODE: ${{ github.event.inputs.mode || 'incremental' }}
          FORCE_REFRESH: ${{ github.event.inputs.force_refresh || 'false' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const { createClient } = require('@supabase/supabase-js');
          const yaml = require('yaml');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;

          if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            process.exit(1);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);
          const GITHUB_RAW_BASE = process.env.GITHUB_RAW_BASE;

          // Helper to fetch URL with retry
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

          function fetchUrl(url, retries = 3) {
            return new Promise((resolve, reject) => {
              const attempt = (retriesLeft) => {
                const headers = { 'User-Agent': 'IntuneGet-Manifest-Sync' };
                if (GITHUB_TOKEN && url.includes('api.github.com')) {
                  headers['Authorization'] = `token ${GITHUB_TOKEN}`;
                }
                https.get(url, { headers }, (res) => {
                  if (res.statusCode === 404) {
                    resolve(null);
                    return;
                  }
                  if (res.statusCode === 403 || res.statusCode === 429) {
                    // Rate limited - wait and retry
                    const retryAfter = parseInt(res.headers['retry-after'] || '5', 10);
                    if (retriesLeft > 0) {
                      setTimeout(() => attempt(retriesLeft - 1), retryAfter * 1000);
                      return;
                    }
                  }
                  if (res.statusCode !== 200) {
                    if (retriesLeft > 0 && res.statusCode >= 500) {
                      setTimeout(() => attempt(retriesLeft - 1), 1000);
                      return;
                    }
                    reject(new Error(`HTTP ${res.statusCode}`));
                    return;
                  }

                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => resolve(data));
                }).on('error', (err) => {
                  if (retriesLeft > 0) {
                    setTimeout(() => attempt(retriesLeft - 1), 1000);
                  } else {
                    reject(err);
                  }
                });
              };
              attempt(retries);
            });
          }

          // Build manifest URL
          function buildManifestUrl(wingetId, version, type = 'installer') {
            const parts = wingetId.split('.');
            if (parts.length < 2) return null;

            const publisher = parts[0];
            // Join remaining parts with '/' for folder path
            const namePath = parts.slice(1).join('/');
            const firstLetter = publisher.charAt(0).toLowerCase();

            return `${GITHUB_RAW_BASE}/${firstLetter}/${publisher}/${namePath}/${version}/${wingetId}.${type}.yaml`;
          }

          // Build version list URL
          function buildVersionListUrl(wingetId) {
            const parts = wingetId.split('.');
            if (parts.length < 2) return null;

            const publisher = parts[0];
            // Join remaining parts with '/' for folder path, URL-encode special chars
            const namePath = parts.slice(1).map(p => encodeURIComponent(p)).join('/');
            const firstLetter = publisher.charAt(0).toLowerCase();

            // GitHub API to list directories
            return `https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/${firstLetter}/${encodeURIComponent(publisher)}/${namePath}`;
          }

          // Fetch available versions for a package
          async function fetchVersions(wingetId) {
            const url = buildVersionListUrl(wingetId);
            if (!url) return [];

            try {
              const response = await fetchUrl(url);
              if (!response) return [];

              const dirs = JSON.parse(response);

              // Filter to only version-like directories
              const versionPattern = /^\d+[\d._-]*\d*$/;

              return dirs
                .filter(d => d.type === 'dir')
                .map(d => d.name)
                .filter(name => versionPattern.test(name) || name.includes('.'))
                .filter(name => /^\d/.test(name))
                .sort((a, b) => b.localeCompare(a, undefined, { numeric: true }));
            } catch (e) {
              // Don't log every failure - too noisy at scale
              return [];
            }
          }

          // Fetch and parse installer manifest
          async function fetchInstallerManifest(wingetId, version) {
            const url = buildManifestUrl(wingetId, version, 'installer');
            if (!url) return null;

            try {
              const content = await fetchUrl(url);
              if (!content) return null;

              return yaml.parse(content);
            } catch (e) {
              return null;
            }
          }

          // Fetch locale manifest for description
          async function fetchLocaleManifest(wingetId, version) {
            const locales = ['locale.en-US', 'locale'];

            for (const locale of locales) {
              const url = buildManifestUrl(wingetId, version, locale);
              if (!url) continue;

              try {
                const content = await fetchUrl(url);
                if (content) {
                  return yaml.parse(content);
                }
              } catch (e) {
                // Continue to next locale
              }
            }
            return null;
          }

          // Main sync function
          async function syncManifests() {
            const appIds = process.env.APP_IDS;
            const appLimit = parseInt(process.env.APP_LIMIT || '2000', 10);
            const syncMode = process.env.SYNC_MODE || 'incremental';
            const forceRefresh = process.env.FORCE_REFRESH === 'true';

            // Update sync status
            await supabase.from('curated_sync_status').upsert({
              id: 'sync-manifests',
              last_run_started_at: new Date().toISOString(),
              last_run_status: 'running',
              metadata: { mode: syncMode },
              updated_at: new Date().toISOString()
            });

            let apps = [];

            if (appIds === 'all') {
              // Build query based on sync mode
              let query = supabase
                .from('curated_apps')
                .select('winget_id, latest_version')
                .order('popularity_rank', { ascending: true, nullsFirst: false });

              // Apply mode-specific filters
              if (syncMode === 'incremental') {
                // Apps without latest_version (need manifest data)
                query = query.is('latest_version', null);
              } else if (syncMode === 'new_only') {
                // Apps that have never been synced - no version_history at all
                // This requires a more complex query, so we'll filter after fetch
                query = query.is('latest_version', null);
              }
              // 'all' mode - no additional filter

              const { data, error } = await query;

              if (error) {
                throw error;
              }
              apps = data || [];
            } else {
              // Parse specific app IDs
              apps = appIds.split(',').map(id => ({ winget_id: id.trim() }));
            }

            // Apply limit
            if (appLimit > 0 && apps.length > appLimit) {
              console.log(`Limiting to ${appLimit} apps (from ${apps.length} total)`);
              apps = apps.slice(0, appLimit);
            }

            // Process in batches
            // With GITHUB_TOKEN: 5000 req/hr. Without: 60 req/hr.
            const batchSize = GITHUB_TOKEN ? 20 : 5;
            const batchDelay = GITHUB_TOKEN ? 500 : 3000;
            const delay = ms => new Promise(r => setTimeout(r, ms));

            console.log(`\n========================================`);
            console.log(`  Sync Winget Manifests`);
            console.log(`========================================`);
            console.log(`  Mode:          ${syncMode}`);
            console.log(`  Force refresh: ${forceRefresh}`);
            console.log(`  Apps to sync:  ${apps.length}`);
            console.log(`  Batch size:    ${batchSize}`);
            console.log(`  Batch delay:   ${batchDelay}ms`);
            console.log(`  Authenticated: ${!!GITHUB_TOKEN}`);
            console.log(`========================================\n`);

            let synced = 0;
            let failed = 0;
            let skipped = 0;
            let failedApps = [];
            let skippedNoVersions = 0;
            let skippedExisting = 0;
            let skippedNoManifest = 0;
            let newVersions = [];
            const startTime = Date.now();

            for (let i = 0; i < apps.length; i += batchSize) {
              const batch = apps.slice(i, i + batchSize);

              await Promise.all(batch.map(async (app) => {
                try {
                  // Fetch available versions
                  const versions = await fetchVersions(app.winget_id);

                  if (versions.length === 0) {
                    skipped++;
                    skippedNoVersions++;
                    return;
                  }

                  const latestVersion = versions[0];

                  // Check if we already have this version
                  if (!forceRefresh) {
                    const { data: existing } = await supabase
                      .from('version_history')
                      .select('version')
                      .eq('winget_id', app.winget_id)
                      .eq('version', latestVersion)
                      .single();

                    if (existing) {
                      skipped++;
                      skippedExisting++;
                      return;
                    }
                  }

                  // Fetch installer manifest
                  const installerManifest = await fetchInstallerManifest(app.winget_id, latestVersion);

                  if (!installerManifest) {
                    failed++;
                    skippedNoManifest++;
                    failedApps.push({ id: app.winget_id, reason: 'no installer manifest' });
                    return;
                  }

                  // Fetch locale manifest for metadata
                  const localeManifest = await fetchLocaleManifest(app.winget_id, latestVersion);

                  // Extract installer data
                  const rawInstallers = installerManifest.Installers || [];
                  const defaultInstaller = rawInstallers[0] || {};

                  // Inherit root-level manifest fields into each installer so the
                  // JSONB is self-contained (individual installers may omit fields
                  // that are defined at the manifest root, e.g. InstallerType).
                  const rootType = installerManifest.InstallerType || null;
                  const rootScope = installerManifest.Scope || null;
                  const rootSwitches = installerManifest.InstallerSwitches || null;
                  const installers = rawInstallers.map(inst => ({
                    ...inst,
                    InstallerType: inst.InstallerType || rootType,
                    Scope: inst.Scope || rootScope,
                    InstallerSwitches: inst.InstallerSwitches || rootSwitches,
                  }));

                  // Prepare version history record
                  const versionRecord = {
                    winget_id: app.winget_id,
                    version: latestVersion,
                    installer_url: defaultInstaller.InstallerUrl || null,
                    installer_sha256: defaultInstaller.InstallerSha256 || null,
                    installer_type: defaultInstaller.InstallerType ||
                                    installerManifest.InstallerType || null,
                    installer_scope: defaultInstaller.Scope ||
                                     installerManifest.Scope || null,
                    silent_args: defaultInstaller.InstallerSwitches?.Silent ||
                                 installerManifest.InstallerSwitches?.Silent ||
                                 defaultInstaller.InstallerSwitches?.SilentWithProgress ||
                                 installerManifest.InstallerSwitches?.SilentWithProgress || null,
                    installers,
                    minimum_os_version: installerManifest.MinimumOSVersion || null,
                    platform: installerManifest.Platform || null,
                    upgrade_behavior: installerManifest.UpgradeBehavior || null,
                    release_notes: localeManifest?.ReleaseNotes || null,
                    manifest_yaml: yaml.stringify(installerManifest),
                    manifest_fetched_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                  };

                  // Upsert version history
                  const { error: vhError } = await supabase
                    .from('version_history')
                    .upsert(versionRecord, {
                      onConflict: 'winget_id,version'
                    });

                  if (vhError) {
                    console.error(`  [FAIL] ${app.winget_id}: DB upsert error - ${vhError.message}`);
                    failed++;
                    failedApps.push({ id: app.winget_id, reason: `DB: ${vhError.message}` });
                    return;
                  }

                  // Update curated_apps with latest version and metadata
                  const { error: caError } = await supabase
                    .from('curated_apps')
                    .update({
                      latest_version: latestVersion,
                      description: localeManifest?.ShortDescription ||
                                   localeManifest?.Description || null,
                      homepage: localeManifest?.PackageUrl ||
                                localeManifest?.PublisherUrl || null,
                      license: localeManifest?.License || null,
                      updated_at: new Date().toISOString()
                    })
                    .eq('winget_id', app.winget_id);

                  if (caError) {
                    console.error(`  [WARN] ${app.winget_id}: curated_apps update failed - ${caError.message}`);
                  }

                  // Track new versions
                  if (app.latest_version && app.latest_version !== latestVersion) {
                    newVersions.push({
                      winget_id: app.winget_id,
                      old_version: app.latest_version,
                      new_version: latestVersion
                    });
                  }

                  synced++;
                } catch (e) {
                  failed++;
                  failedApps.push({ id: app.winget_id, reason: e.message || String(e) });
                }
              }));

              // Rate limiting for GitHub API
              if (i + batchSize < apps.length) {
                await delay(batchDelay);
              }

              // Progress logging every 5 batches or at the end
              const processed = Math.min(i + batchSize, apps.length);
              if ((i / batchSize) % 5 === 0 || processed >= apps.length) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                const rate = (processed / (Date.now() - startTime) * 1000).toFixed(1);
                console.log(`  [${elapsed}s] ${processed}/${apps.length} | synced: ${synced} | failed: ${failed} | skipped: ${skipped} (no-versions: ${skippedNoVersions}, existing: ${skippedExisting}, no-manifest: ${skippedNoManifest}) | ${rate} apps/s`);
              }
            }

            // Update sync status
            await supabase.from('curated_sync_status').upsert({
              id: 'sync-manifests',
              last_run_completed_at: new Date().toISOString(),
              last_run_status: failed > 0 && synced === 0 ? 'failed' : 'success',
              items_processed: synced,
              error_message: failed > 0 ? `${failed} apps failed to sync` : null,
              metadata: {
                mode: syncMode,
                synced,
                failed,
                skipped,
                new_versions: newVersions.length
              },
              updated_at: new Date().toISOString()
            });

            const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);

            console.log(`\n========================================`);
            console.log(`  Sync Complete`);
            console.log(`========================================`);
            console.log(`  Duration:    ${totalTime}s`);
            console.log(`  Synced:      ${synced}`);
            console.log(`  Failed:      ${failed}`);
            console.log(`  Skipped:     ${skipped}`);
            console.log(`    - No versions found: ${skippedNoVersions}`);
            console.log(`    - Already up to date: ${skippedExisting}`);
            console.log(`    - No manifest found:  ${skippedNoManifest}`);
            console.log(`========================================`);

            if (failedApps.length > 0) {
              console.log(`\nFailed apps (showing first 30):`);
              for (const f of failedApps.slice(0, 30)) {
                console.log(`  - ${f.id}: ${f.reason}`);
              }
              if (failedApps.length > 30) {
                console.log(`  ... and ${failedApps.length - 30} more`);
              }
            }

            if (newVersions.length > 0) {
              console.log(`\nNew versions detected:`);
              for (const v of newVersions.slice(0, 20)) {
                console.log(`  ${v.winget_id}: ${v.old_version} -> ${v.new_version}`);
              }
              if (newVersions.length > 20) {
                console.log(`  ... and ${newVersions.length - 20} more`);
              }
            }

            // Output for workflow
            fs.writeFileSync('./sync-results.json', JSON.stringify({
              synced, failed, skipped, newVersions
            }));
          }

          syncManifests().catch(err => {
            console.error('Sync failed:', err);
            process.exit(1);
          });
          EOF

      - name: Create summary
        run: |
          if [ -f sync-results.json ]; then
            SYNCED=$(jq -r '.synced' sync-results.json)
            FAILED=$(jq -r '.failed' sync-results.json)
            SKIPPED=$(jq -r '.skipped' sync-results.json)
            NEW_VERSIONS=$(jq -r '.newVersions | length' sync-results.json)

            echo "## Manifest Sync Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Mode:** ${{ github.event.inputs.mode || 'incremental' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Synced:** $SYNCED" >> $GITHUB_STEP_SUMMARY
            echo "- **Failed:** $FAILED" >> $GITHUB_STEP_SUMMARY
            echo "- **Skipped (up-to-date):** $SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "- **New versions detected:** $NEW_VERSIONS" >> $GITHUB_STEP_SUMMARY

            if [ "$NEW_VERSIONS" -gt 0 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### New Versions (first 20)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.newVersions[:20][] | "- **\(.winget_id):** \(.old_version) -> \(.new_version)"' sync-results.json >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Trigger scan workflow for new versions
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -f sync-results.json ]; then
            NEW_VERSIONS=$(jq -r '.newVersions | length' sync-results.json)

            if [ "$NEW_VERSIONS" -gt 0 ]; then
              # Get list of app IDs with new versions (limit to 10 for scan)
              APP_IDS=$(jq -r '[.newVersions[:10][].winget_id] | join(",")' sync-results.json)

              echo "Triggering scan workflow for: $APP_IDS"

              # Trigger scan-apps workflow (if it exists)
              gh workflow run scan-apps.yml \
                -f app_ids="$APP_IDS" \
                -f trigger_source="sync-manifests" || echo "Scan workflow not available or failed to trigger"
            fi
          fi

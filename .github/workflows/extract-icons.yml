name: Extract App Icons

on:
  # Automatically run after Build Curated App List completes
  workflow_run:
    workflows: ["Build Curated App List"]
    types: [completed]
    branches: [main, master]
  schedule:
    # Run weekly on Saturdays at 04:00 UTC (fallback)
    - cron: '0 4 * * 6'
  workflow_dispatch:
    inputs:
      app_ids:
        description: 'Specific app IDs to extract icons for (comma-separated, or "all")'
        required: false
        default: 'all'
      max_apps:
        description: 'Maximum number of apps to process'
        required: false
        default: '100'
      force_refresh:
        description: 'Re-extract icons even if they exist'
        required: false
        default: 'false'
        type: boolean
      skip_binary:
        description: 'Skip binary extraction (run web icon fetch only)'
        required: false
        default: 'false'
        type: boolean

# Prevent concurrent runs that could cause git conflicts
# Use same group as build-app-list and sync-manifests to ensure sequential execution
concurrency:
  group: curated-apps-pipeline
  cancel-in-progress: false

env:
  MAX_APPS: ${{ github.event.inputs.max_apps || '100' }}

permissions:
  contents: write

jobs:
  # ============================================================
  # Job 1: Fetch icons from web sources (GitHub avatars, favicons)
  # Runs on Ubuntu -- fast and cheap
  # ============================================================
  extract-web-icons:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    outputs:
      web_committed: ${{ steps.commit-web-icons.outputs.committed }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci && npm install --no-save sharp

      - name: Fetch web icons
        id: fetch-web-icons
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          MAX_APPS: ${{ env.MAX_APPS }}
          ICONS_DIR: public/icons
        run: node .github/scripts/fetch-web-icons.mjs

      - name: Commit web icons
        id: commit-web-icons
        if: steps.fetch-web-icons.outputs.total_hits != '0'
        shell: bash
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          STASH_CREATED=false
          git add public/icons/ || true
          if ! git diff --staged --quiet 2>/dev/null; then
            git stash --include-untracked
            STASH_CREATED=true
          fi

          git fetch origin main
          git checkout main || git checkout -b main origin/main
          git pull origin main

          if [ "$STASH_CREATED" = true ]; then
            git stash pop || true
          fi

          git add public/icons/ || true

          if git diff --staged --quiet; then
            echo "No new web icons to commit"
            echo "committed=false" >> $GITHUB_OUTPUT
            echo "committed_apps=" >> $GITHUB_OUTPUT
          else
            COMMITTED_APPS=$(git diff --staged --name-only | grep "icon-64.png" | sed 's|public/icons/\(.*\)/icon-64.png|\1|' | tr '\n' ',' | sed 's/,$//')
            ICON_COUNT=$(echo "$COMMITTED_APPS" | tr ',' '\n' | grep -c . || echo "0")

            git commit -m "chore: add web-sourced icons for $ICON_COUNT apps"

            PUSH_SUCCESS=false
            for i in 1 2 3; do
              if git pull --rebase origin main && git push origin main; then
                PUSH_SUCCESS=true
                break
              fi
              echo "Retry $i: pull/push failed, retrying..."
              sleep 5
            done

            if [ "$PUSH_SUCCESS" = true ]; then
              echo "committed=true" >> $GITHUB_OUTPUT
              echo "committed_apps=$COMMITTED_APPS" >> $GITHUB_OUTPUT
            else
              echo "committed=false" >> $GITHUB_OUTPUT
              echo "committed_apps=" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Update database with web icons
        if: steps.commit-web-icons.outputs.committed == 'true'
        shell: bash
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          COMMITTED_APPS: ${{ steps.commit-web-icons.outputs.committed_apps }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const committedApps = process.env.COMMITTED_APPS ? process.env.COMMITTED_APPS.split(',').filter(Boolean) : [];

          if (!supabaseUrl || !supabaseKey || committedApps.length === 0) {
            console.log('No apps to update');
            process.exit(0);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function updateDatabase() {
            const results = JSON.parse(fs.readFileSync('web-icon-results.json', 'utf8'));
            const toUpdate = results.filter(r =>
              r.status === 'success' && committedApps.includes(r.winget_id)
            );

            console.log(`Updating database for ${toUpdate.length} web-sourced icons`);

            for (const result of toUpdate) {
              const { error } = await supabase
                .from('curated_apps')
                .update({
                  icon_path: result.icon_path,
                  has_icon: true,
                  icon_source: result.icon_source,
                  updated_at: new Date().toISOString()
                })
                .eq('winget_id', result.winget_id);

              if (error) {
                console.error(`Failed to update ${result.winget_id}:`, error.message);
              }
            }

            await supabase.from('curated_sync_status').upsert({
              id: 'extract-icons-web',
              last_run_completed_at: new Date().toISOString(),
              last_run_status: 'success',
              items_processed: toUpdate.length,
              metadata: {
                github_avatars: toUpdate.filter(r => r.icon_source === 'github_avatar').length,
                favicons: toUpdate.filter(r => r.icon_source === 'favicon').length
              },
              updated_at: new Date().toISOString()
            });

            console.log(`Updated ${toUpdate.length} apps with web icon paths`);
          }

          updateDatabase().catch(err => {
            console.error('Database update failed:', err);
            process.exit(1);
          });
          EOF

      - name: Web icons summary
        if: always()
        run: |
          if [ -f web-icon-results.json ]; then
            echo "## Web Icon Fetch Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            SUCCESS=$(jq '[.[] | select(.status == "success")] | length' web-icon-results.json)
            GITHUB=$(jq '[.[] | select(.icon_source == "github_avatar")] | length' web-icon-results.json)
            FAVICON=$(jq '[.[] | select(.icon_source == "favicon")] | length' web-icon-results.json)
            TOTAL=$(jq 'length' web-icon-results.json)
            echo "- **GitHub avatars:** $GITHUB" >> $GITHUB_STEP_SUMMARY
            echo "- **Favicons:** $FAVICON" >> $GITHUB_STEP_SUMMARY
            echo "- **Total success:** $SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Total processed:** $TOTAL" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================
  # Job 2: Extract icons from installer binaries (EXE/MSI/MSIX)
  # Runs on Windows -- slower but highest quality
  # ============================================================
  extract-binary-icons:
    runs-on: windows-latest
    needs: [extract-web-icons]
    timeout-minutes: 180
    if: >
      inputs.skip_binary != 'true' &&
      (github.event_name == 'workflow_dispatch' ||
       github.event_name == 'schedule' ||
       (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'))

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main
          fetch-depth: 0

      - name: Pull latest (includes web icons)
        run: git pull origin main
        shell: bash

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install ImageMagick and 7-Zip
        run: |
          choco install imagemagick.app 7zip -y --no-progress
          refreshenv
          if (Test-Path "C:\Program Files\7-Zip\7z.exe") {
            Write-Host "7-Zip installed successfully"
          } else {
            Write-Host "7-Zip not found at expected path, checking alternatives..."
            Get-Command 7z -ErrorAction SilentlyContinue
          }
        shell: pwsh

      - name: Get apps to process
        id: get-apps
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          APP_IDS: ${{ github.event.inputs.app_ids || 'all' }}
          FORCE_REFRESH: ${{ github.event.inputs.force_refresh || 'false' }}
          MAX_APPS: ${{ env.MAX_APPS }}
        shell: bash
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const appIds = process.env.APP_IDS || 'all';
          const forceRefresh = process.env.FORCE_REFRESH === 'true';
          const maxApps = parseInt(process.env.MAX_APPS) || 100;

          if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            process.exit(1);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function getApps() {
            let query = supabase
              .from('curated_apps')
              .select('winget_id, name, publisher, latest_version, icon_extraction_attempts');

            if (appIds !== 'all') {
              const targetIds = appIds.split(',').map(id => id.trim());
              query = query.in('winget_id', targetIds);
            }

            if (!forceRefresh) {
              query = query.or('has_icon.is.null,has_icon.eq.false');
            }

            if (!forceRefresh) {
              query = query.or('icon_extraction_attempts.is.null,icon_extraction_attempts.lt.3');
            }

            query = query.limit(maxApps);

            const { data: apps, error } = await query;

            if (error) {
              console.error('Failed to fetch apps:', error.message);
              process.exit(1);
            }

            const wingetIds = apps.map(a => a.winget_id);
            const installerUrlMap = {};
            if (wingetIds.length > 0) {
              const { data: vhRows } = await supabase
                .from('version_history')
                .select('winget_id, installer_url')
                .in('winget_id', wingetIds)
                .not('installer_url', 'is', null)
                .order('detected_at', { ascending: false });

              if (vhRows) {
                for (const row of vhRows) {
                  if (!installerUrlMap[row.winget_id]) {
                    installerUrlMap[row.winget_id] = row.installer_url;
                  }
                }
              }
              console.log(`Found ${Object.keys(installerUrlMap).length} cached installer URLs from version_history`);
            }

            const appsToProcess = [];
            for (const app of apps) {
              const iconPath = `public/icons/${app.winget_id}/icon-64.png`;
              if (forceRefresh || !fs.existsSync(iconPath)) {
                const attempts = app.icon_extraction_attempts || 0;
                if (!forceRefresh && attempts >= 3) {
                  console.log(`Skipping ${app.winget_id} (${attempts} failed attempts)`);
                  continue;
                }
                app.cached_installer_url = installerUrlMap[app.winget_id] || null;
                appsToProcess.push(app);
              }
              if (appsToProcess.length >= maxApps) break;
            }

            console.log(`Processing ${appsToProcess.length} apps for binary icon extraction`);

            fs.writeFileSync('apps-to-process.json', JSON.stringify(appsToProcess, null, 2));

            const outputFile = process.env.GITHUB_OUTPUT;
            if (outputFile) {
              fs.appendFileSync(outputFile, `app_count=${appsToProcess.length}\n`);
            }
          }

          getApps().catch(err => {
            console.error('Error:', err);
            process.exit(1);
          });
          EOF

      - name: Extract icons
        if: steps.get-apps.outputs.app_count != '0'
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Continue'

          $apps = Get-Content "apps-to-process.json" | ConvertFrom-Json

          $extracted = 0
          $failed = 0
          $results = @()

          foreach ($app in $apps) {
            $wingetId = $app.winget_id
            Write-Host "`n=== Processing $wingetId ===" -ForegroundColor Cyan

            $failureReason = $null

            try {
              $iconDir = "public/icons/$wingetId"
              New-Item -ItemType Directory -Path $iconDir -Force | Out-Null

              $installerUrl = $null
              $installerPath = $null

              $parts = $wingetId.Split('.')
              $publisher = $parts[0]
              $firstLetter = $publisher.Substring(0,1).ToLower()

              $namePath = $parts[1..($parts.Length-1)] -join '/'
              $rawBaseUrl = "https://raw.githubusercontent.com/microsoft/winget-pkgs/master/manifests/$firstLetter/$publisher/$namePath"

              $encodedParts = $parts[1..($parts.Length-1)] | ForEach-Object { [uri]::EscapeDataString($_) }
              $encodedNamePath = $encodedParts -join '/'
              $encodedPublisher = [uri]::EscapeDataString($publisher)
              $apiBaseUrl = "https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/$firstLetter/$encodedPublisher/$encodedNamePath"

              if ($app.cached_installer_url) {
                Write-Host "Tier 1: Using cached installer URL from version_history"
                $installerUrl = $app.cached_installer_url
              }

              if (-not $installerUrl -and $app.latest_version) {
                try {
                  $latestVersion = $app.latest_version
                  Write-Host "Tier 2: Using latest_version '$latestVersion' with raw URL"
                  $installerYamlUrl = "$rawBaseUrl/$latestVersion/$wingetId.installer.yaml"
                  $yamlContent = Invoke-WebRequest -Uri $installerYamlUrl -UseBasicParsing -ErrorAction Stop -TimeoutSec 30

                  $lines = $yamlContent.Content -split "`n"
                  foreach ($line in $lines) {
                    if ($line -match 'InstallerUrl:\s*(.+)') {
                      $installerUrl = $matches[1].Trim()
                      break
                    }
                  }
                } catch {
                  Write-Host "Tier 2 failed for $wingetId : $($_.Exception.Message)"
                }
              }

              if (-not $installerUrl) {
                try {
                  Write-Host "Tier 3: Listing versions via GitHub API"
                  $versions = Invoke-RestMethod -Uri $apiBaseUrl -Headers @{ 'User-Agent' = 'IntuneGet' } -ErrorAction Stop -TimeoutSec 30
                  $versionDirs = $versions | Where-Object { $_.type -eq 'dir' -and $_.name -match '^\d' }
                  $latestVersion = ($versionDirs | Sort-Object { [version]($_.name -replace '[^\d.]', '.') } -Descending -ErrorAction SilentlyContinue | Select-Object -First 1).name
                  if (-not $latestVersion) {
                    $latestVersion = ($versionDirs | Sort-Object name -Descending | Select-Object -First 1).name
                  }

                  if ($latestVersion) {
                    $installerYamlUrl = "$rawBaseUrl/$latestVersion/$wingetId.installer.yaml"
                    $yamlContent = Invoke-WebRequest -Uri $installerYamlUrl -UseBasicParsing -ErrorAction Stop -TimeoutSec 30

                    $lines = $yamlContent.Content -split "`n"
                    foreach ($line in $lines) {
                      if ($line -match 'InstallerUrl:\s*(.+)') {
                        $installerUrl = $matches[1].Trim()
                        break
                      }
                    }
                  }
                } catch {
                  Write-Warning "Tier 3 failed for $wingetId : $_"
                }
              }

              if (-not $installerUrl) {
                Write-Warning "No installer URL found for $wingetId"
                $failureReason = 'no_installer_url'
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = 'no_installer_url'
                  failure_reason = $failureReason
                }
                continue
              }

              $extension = if ($installerUrl -match '\.msi(\?|$)') { '.msi' }
                          elseif ($installerUrl -match '\.msixbundle(\?|$)') { '.msixbundle' }
                          elseif ($installerUrl -match '\.msix(\?|$)') { '.msix' }
                          elseif ($installerUrl -match '\.appx(\?|$)') { '.appx' }
                          else { '.exe' }

              $installerPath = "$env:TEMP\installer_$([System.IO.Path]::GetRandomFileName())$extension"

              Write-Host "Downloading installer from $installerUrl"
              try {
                Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath -UseBasicParsing -MaximumRedirection 5 -TimeoutSec 90
              } catch {
                Write-Warning "Download failed or timed out for ${wingetId}: $_"
                $failureReason = 'download_timeout'
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = "Download timeout or error"
                  failure_reason = $failureReason
                }
                continue
              }

              if (-not (Test-Path $installerPath)) {
                Write-Warning "Failed to download installer for $wingetId"
                $failureReason = 'download_failed'
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = 'download_failed'
                  failure_reason = $failureReason
                }
                continue
              }

              $fileSize = (Get-Item $installerPath).Length
              $fileSizeMB = [math]::Round($fileSize / 1MB, 1)
              Write-Host "Downloaded $fileSizeMB MB"
              if ($fileSize -gt 500MB) {
                Write-Warning "Installer too large ($fileSizeMB MB) for $wingetId, skipping"
                Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
                $failureReason = 'installer_too_large'
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = "Installer too large: ${fileSizeMB}MB"
                  failure_reason = $failureReason
                }
                continue
              }

              $iconSourceType = switch ($extension) {
                '.msi' { 'binary_msi' }
                '.msix' { 'binary_msix' }
                '.msixbundle' { 'binary_msix' }
                '.appx' { 'binary_msix' }
                default { 'binary_exe' }
              }

              $extractResult = & "$env:GITHUB_WORKSPACE\.github\scripts\extract-icon.ps1" `
                -InstallerPath $installerPath `
                -OutputDir $iconDir `
                -AppId $wingetId 2>&1
              $extractExitCode = $LASTEXITCODE

              if ($extractExitCode -ne 0) {
                Write-Host "Icon extraction script returned exit code: $extractExitCode"
                Write-Host $extractResult
              }

              if (Test-Path "$iconDir/icon-64.png") {
                Write-Host "Successfully extracted icon for $wingetId" -ForegroundColor Green
                $extracted++
                $results += @{
                  winget_id = $wingetId
                  status = 'success'
                  icon_path = "/icons/$wingetId/"
                  icon_source = $iconSourceType
                }
              } else {
                Write-Warning "No icon extracted for $wingetId"
                $failureReason = 'no_icon_in_binary'
                $failed++
                $results += @{
                  winget_id = $wingetId
                  status = 'failed'
                  error = 'No icon extracted'
                  failure_reason = $failureReason
                }
              }
            } catch {
              Write-Warning "Error processing $wingetId : $_"
              $failureReason = 'extraction_error'
              $failed++
              $results += @{
                winget_id = $wingetId
                status = 'failed'
                error = $_.ToString()
                failure_reason = $failureReason
              }
            } finally {
              if ($installerPath -and (Test-Path $installerPath)) {
                Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
              }
            }

            Start-Sleep -Seconds 1
          }

          Write-Host "`n=== Binary Icon Extraction Summary ===" -ForegroundColor Cyan
          Write-Host "Extracted: $extracted"
          Write-Host "Failed: $failed"

          $results | ConvertTo-Json -Depth 10 | Out-File "icon-results.json" -Encoding UTF8

          echo "extracted=$extracted" >> $env:GITHUB_OUTPUT
          echo "failed=$failed" >> $env:GITHUB_OUTPUT

          exit 0

      - name: Commit icons
        id: commit-icons
        if: steps.get-apps.outputs.app_count != '0'
        shell: bash
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          STASH_CREATED=false
          git add public/icons/ || true
          if ! git diff --staged --quiet 2>/dev/null; then
            git stash --include-untracked
            STASH_CREATED=true
          fi

          git fetch origin main
          git checkout main || git checkout -b main origin/main
          git pull origin main

          if [ "$STASH_CREATED" = true ]; then
            git stash pop || true
          fi

          git add public/icons/ || true

          if git diff --staged --quiet; then
            echo "No new icons to commit"
            echo "committed=false" >> $GITHUB_OUTPUT
            echo "committed_apps=" >> $GITHUB_OUTPUT
          else
            COMMITTED_APPS=$(git diff --staged --name-only | grep "icon-64.png" | sed 's|public/icons/\(.*\)/icon-64.png|\1|' | tr '\n' ',' | sed 's/,$//')
            ICON_COUNT=$(echo "$COMMITTED_APPS" | tr ',' '\n' | grep -c . || echo "0")

            git commit -m "chore: add icons for $ICON_COUNT apps"

            PUSH_SUCCESS=false
            for i in 1 2 3; do
              if git pull --rebase origin main && git push origin main; then
                PUSH_SUCCESS=true
                break
              fi
              echo "Retry $i: pull/push failed, retrying..."
              sleep 5
            done

            if [ "$PUSH_SUCCESS" = true ]; then
              echo "committed=true" >> $GITHUB_OUTPUT
              echo "committed_apps=$COMMITTED_APPS" >> $GITHUB_OUTPUT
            else
              echo "committed=false" >> $GITHUB_OUTPUT
              echo "committed_apps=" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Update database
        if: steps.get-apps.outputs.app_count != '0'
        shell: bash
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          COMMITTED_APPS: ${{ steps.commit-icons.outputs.committed_apps }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const committedApps = process.env.COMMITTED_APPS ? process.env.COMMITTED_APPS.split(',').filter(Boolean) : [];

          if (!supabaseUrl || !supabaseKey) {
            console.log('Supabase credentials not configured, skipping database update');
            process.exit(0);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function updateDatabase() {
            const results = JSON.parse(fs.readFileSync('icon-results.json', 'utf8'));

            const toUpdate = results.filter(r =>
              r.status === 'success' && committedApps.includes(r.winget_id)
            );

            console.log(`Updating database for ${toUpdate.length} committed binary icons`);

            for (const result of toUpdate) {
              const { error } = await supabase
                .from('curated_apps')
                .update({
                  icon_path: result.icon_path,
                  has_icon: true,
                  icon_source: result.icon_source || 'binary_exe',
                  icon_extraction_attempts: 0,
                  icon_failure_reason: null,
                  icon_last_attempted_at: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                })
                .eq('winget_id', result.winget_id);

              if (error) {
                console.error(`Failed to update ${result.winget_id}:`, error.message);
              } else {
                console.log(`Updated ${result.winget_id} (source: ${result.icon_source})`);
              }
            }

            const failedResults = results.filter(r => r.status === 'failed');
            console.log(`Recording ${failedResults.length} failed extraction attempts`);

            for (const result of failedResults) {
              const { data: current } = await supabase
                .from('curated_apps')
                .select('icon_extraction_attempts')
                .eq('winget_id', result.winget_id)
                .single();

              const currentAttempts = current?.icon_extraction_attempts || 0;

              await supabase
                .from('curated_apps')
                .update({
                  icon_extraction_attempts: currentAttempts + 1,
                  icon_failure_reason: result.failure_reason || 'unknown',
                  icon_last_attempted_at: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                })
                .eq('winget_id', result.winget_id);
            }

            await supabase.from('curated_sync_status').upsert({
              id: 'extract-icons',
              last_run_completed_at: new Date().toISOString(),
              last_run_status: 'success',
              items_processed: toUpdate.length,
              metadata: {
                total: results.length,
                successful: toUpdate.length,
                failed: failedResults.length,
                failure_breakdown: failedResults.reduce((acc, r) => {
                  const reason = r.failure_reason || 'unknown';
                  acc[reason] = (acc[reason] || 0) + 1;
                  return acc;
                }, {})
              },
              updated_at: new Date().toISOString()
            });

            console.log('Database update complete');
          }

          updateDatabase()
            .then(() => process.exit(0))
            .catch(err => {
              console.error('Database update failed:', err);
              process.exit(1);
            });
          EOF

      - name: Create summary
        run: |
          if (Test-Path icon-results.json) {
            $results = Get-Content icon-results.json | ConvertFrom-Json
            $success = ($results | Where-Object { $_.status -eq 'success' }).Count
            $failed = ($results | Where-Object { $_.status -eq 'failed' }).Count

            @"
          ## Binary Icon Extraction Summary

          - **Successfully extracted:** $success
          - **Failed:** $failed
          - **Total processed:** $($results.Count)

          ### Failure Breakdown
          "@ | Out-File -Append $env:GITHUB_STEP_SUMMARY

            $failureGroups = $results | Where-Object { $_.status -eq 'failed' } | Group-Object -Property failure_reason
            foreach ($group in $failureGroups) {
              "- **$($group.Name):** $($group.Count)" | Out-File -Append $env:GITHUB_STEP_SUMMARY
            }

            @"

          ### Extracted Icons
          "@ | Out-File -Append $env:GITHUB_STEP_SUMMARY

            foreach ($r in ($results | Where-Object { $_.status -eq 'success' } | Select-Object -First 20)) {
              "- $($r.winget_id) ($($r.icon_source))" | Out-File -Append $env:GITHUB_STEP_SUMMARY
            }

            if ($failed -gt 0) {
              @"

          ### Failed Extractions (first 10)
          "@ | Out-File -Append $env:GITHUB_STEP_SUMMARY

              foreach ($r in ($results | Where-Object { $_.status -eq 'failed' } | Select-Object -First 10)) {
                "- $($r.winget_id): $($r.failure_reason) - $($r.error)" | Out-File -Append $env:GITHUB_STEP_SUMMARY
              }
            }
          }
        shell: pwsh

name: Validate Winget IDs

on:
  schedule:
    # Run weekly on Monday at 01:00 UTC (before sync-manifests at 02:00)
    - cron: '0 1 * * 1'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Validation mode'
        required: true
        default: 'both'
        type: choice
        options:
          - validate    # Check existing IDs only
          - discover    # Search for correct IDs for failed validations
          - both        # Validate then discover
      limit:
        description: 'Max apps to process (0 = all)'
        required: false
        default: '200'
      priority:
        description: 'Which apps to prioritize'
        required: true
        default: 'unverified'
        type: choice
        options:
          - unverified  # Apps without is_winget_verified = true
          - no_version  # Apps without latest_version
          - all         # All apps by popularity

# Prevent concurrent runs - part of curated-apps pipeline
concurrency:
  group: curated-apps-pipeline
  cancel-in-progress: false

env:
  NODE_VERSION: '20'

jobs:
  validate:
    runs-on: windows-latest
    timeout-minutes: 120

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Winget
        shell: pwsh
        run: |
          # Check if winget is available
          $winget = Get-Command winget -ErrorAction SilentlyContinue

          if (-not $winget) {
            Write-Host "Installing WinGet..."
            $progressPreference = 'SilentlyContinue'
            $url = "https://aka.ms/getwinget"
            $installerPath = "$env:TEMP\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
            Invoke-WebRequest -Uri $url -OutFile $installerPath
            Add-AppxPackage -Path $installerPath
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          }

          winget --version

          # Update winget sources to ensure we have latest package data
          Write-Host "Updating winget sources..."
          winget source update

      - name: Fetch apps from Supabase
        id: fetch
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          LIMIT: ${{ github.event.inputs.limit || '200' }}
          PRIORITY: ${{ github.event.inputs.priority || 'unverified' }}
        shell: bash
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
          const limit = parseInt(process.env.LIMIT || '200', 10);
          const priority = process.env.PRIORITY || 'unverified';

          if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            process.exit(1);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function fetchApps() {
            let query = supabase
              .from('curated_apps')
              .select('id, winget_id, name, publisher, latest_version, is_winget_verified')
              .order('popularity_rank', { ascending: true });

            // Apply priority filter
            if (priority === 'unverified') {
              // Apps not yet verified by winget
              query = query.or('is_winget_verified.is.null,is_winget_verified.eq.false');
            } else if (priority === 'no_version') {
              // Apps without latest_version (likely invalid winget IDs)
              query = query.is('latest_version', null);
            }
            // 'all' - no additional filter

            if (limit > 0) {
              query = query.limit(limit);
            }

            const { data, error } = await query;

            if (error) {
              console.error('Failed to fetch apps:', error.message);
              process.exit(1);
            }

            console.log(`Fetched ${data.length} apps to validate`);
            fs.writeFileSync('apps-to-validate.json', JSON.stringify(data, null, 2));

            // Output count for GitHub Actions
            const outputFile = process.env.GITHUB_OUTPUT;
            if (outputFile) {
              fs.appendFileSync(outputFile, `app_count=${data.length}\n`);
            }
          }

          fetchApps().catch(err => {
            console.error('Fetch failed:', err);
            process.exit(1);
          });
          EOF

      - name: Validate and Discover IDs
        if: steps.fetch.outputs.app_count != '0'
        id: validate
        env:
          MODE: ${{ github.event.inputs.mode || 'both' }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Continue'
          $mode = $env:MODE

          # Helper function to clean app names for better search results
          function Clean-AppName {
            param([string]$Name)

            $cleaned = $Name
            # Remove parenthetical content: (remove only), (formerly X), etc.
            $cleaned = $cleaned -replace '\s*\([^)]*\)\s*', ' '
            # Remove brackets: [Deprecated], [Preview], etc.
            $cleaned = $cleaned -replace '\s*\[[^\]]*\]\s*', ' '
            # Remove version patterns at end: v1.0, 2019, 2022, etc.
            $cleaned = $cleaned -replace '\s+v?\d+\.?\d*\.?\d*\s*$', ''
            # Remove common suffixes that don't help with search
            $cleaned = $cleaned -replace '\s+(for Windows|Desktop|Client|Edition|Installer|Setup)\s*$', ''
            # Remove workload/component descriptors
            $cleaned = $cleaned -replace '\s+workload\s+for\s+.*$', ''
            # Collapse multiple whitespace
            $cleaned = $cleaned -replace '\s+', ' '

            return $cleaned.Trim()
          }

          # Helper function to extract publisher and app name from existing winget ID
          function Get-IdComponents {
            param([string]$WingetId)

            if (-not $WingetId) { return $null }

            $parts = $WingetId -split '\.'
            if ($parts.Count -ge 2) {
              return @{
                Publisher = $parts[0]
                AppName = ($parts[1..($parts.Count-1)] -join ' ')
              }
            }
            return $null
          }

          # Helper function to parse winget search output
          function Parse-WingetSearch {
            param([string]$Output)

            $results = @()
            $lines = $Output -split "`n"
            $headerFound = $false
            $nameCol = 0
            $idCol = 0
            $versionCol = 0
            $sourceCol = 0

            foreach ($line in $lines) {
              # Skip empty lines
              if ([string]::IsNullOrWhiteSpace($line)) { continue }

              # Find header line (contains "Name" and "Id")
              if (-not $headerFound -and $line -match 'Name\s+Id') {
                $headerFound = $true
                # Determine column positions from header
                $nameCol = $line.IndexOf('Name')
                $idCol = $line.IndexOf('Id')
                $versionCol = $line.IndexOf('Version')
                $sourceCol = $line.IndexOf('Source')
                continue
              }

              # Skip separator line (dashes)
              if ($line -match '^-+$' -or $line -match '^-+\s+-+') { continue }

              # Parse data rows
              if ($headerFound -and $line.Length -gt $idCol) {
                try {
                  # Extract fields based on column positions
                  $name = $line.Substring($nameCol, [Math]::Min($idCol - $nameCol, $line.Length - $nameCol)).Trim()

                  $idEnd = if ($versionCol -gt 0) { $versionCol } else { $line.Length }
                  $id = $line.Substring($idCol, [Math]::Min($idEnd - $idCol, $line.Length - $idCol)).Trim()

                  $version = ""
                  $source = "winget"

                  if ($versionCol -gt 0 -and $line.Length -gt $versionCol) {
                    $verEnd = if ($sourceCol -gt 0) { $sourceCol } else { $line.Length }
                    $version = $line.Substring($versionCol, [Math]::Min($verEnd - $versionCol, $line.Length - $versionCol)).Trim()
                  }

                  if ($sourceCol -gt 0 -and $line.Length -gt $sourceCol) {
                    $source = $line.Substring($sourceCol).Trim()
                  }

                  # Validate ID format (Publisher.Name)
                  if ($id -match '^[A-Za-z0-9]+\.[A-Za-z0-9]') {
                    $results += @{
                      Name = $name
                      Id = $id
                      Version = $version
                      Source = $source
                    }
                  }
                } catch {
                  # Skip malformed lines
                }
              }
            }

            return $results
          }

          # Helper function to find best match from search results
          function Get-BestMatch {
            param(
              [string]$AppName,
              [string]$Publisher,
              [string]$ExistingWingetId,
              [array]$SearchResults,
              [int]$MinScore = 40
            )

            $bestScore = 0
            $bestMatch = $null

            # Extract publisher from existing winget ID for matching (bonus only, no penalty)
            $existingPublisher = $null
            if ($ExistingWingetId -match '^([A-Za-z0-9]+)\.') {
              $existingPublisher = $Matches[1]
            }

            foreach ($result in $SearchResults) {
              $score = 0
              $resultName = $result.Name.ToLower()
              $resultId = $result.Id.ToLower()
              $searchName = $AppName.ToLower()
              $searchPublisher = if ($Publisher) { $Publisher.ToLower() } else { "" }

              # Publisher match bonus (no penalty - existing ID might be wrong)
              if ($existingPublisher -and $result.Id -like "$existingPublisher.*") {
                $score += 50  # Same publisher as existing ID - bonus
              }

              # 1. Exact name match
              if ($resultName -eq $searchName) {
                $score += 80
              }
              # 2. Name starts with search term
              elseif ($resultName.StartsWith($searchName)) {
                $score += 60
              }
              # 3. Name contains search term
              elseif ($resultName -like "*$searchName*") {
                $score += 40
              }

              # 4. ID contains name (normalized)
              $normalizedName = $searchName -replace '[^a-z0-9]', ''
              $normalizedId = $resultId -replace '[^a-z0-9]', ''
              if ($normalizedId -like "*$normalizedName*") {
                $score += 30
              }

              # 5. Publisher match in ID (from database publisher field)
              if ($searchPublisher -and $resultId -like "$searchPublisher.*") {
                $score += 30
              }

              # 6. Prefer 'winget' source
              if ($result.Source -eq 'winget') {
                $score += 10
              }

              # 7. Prefer shorter IDs (more canonical)
              $idParts = $result.Id.Split('.').Count
              if ($idParts -eq 2) { $score += 5 }

              if ($score -gt $bestScore) {
                $bestScore = $score
                $bestMatch = $result
              }
            }

            # Return if confidence meets minimum threshold
            if ($bestScore -ge $MinScore -and $bestMatch) {
              return @{
                Id = $bestMatch.Id
                Score = $bestScore
                Name = $bestMatch.Name
                Version = $bestMatch.Version
              }
            }
            return $null
          }

          # Helper function to query OpenAI Responses API with web search for winget ID
          function Get-WingetIdFromOpenAI {
            param(
              [string]$AppName,
              [string]$Publisher,
              [string]$ExistingWingetId
            )

            $apiKey = $env:OPENAI_API_KEY
            if (-not $apiKey) {
              Write-Host "    OpenAI API key not configured, skipping AI fallback" -ForegroundColor Yellow
              return $null
            }

            try {
              $prompt = "Search the web to find the correct winget package ID for:`n" +
                "- App: $AppName`n" +
                "- Publisher: $Publisher`n" +
                "- Invalid ID: $ExistingWingetId (this ID does not exist in winget)`n`n" +
                "Search winget.run, winstall.app, or github.com/microsoft/winget-pkgs for the correct ID.`n`n" +
                "Rules:`n" +
                "- Winget IDs use format: Publisher.AppName (e.g., Microsoft.VisualStudioCode)`n" +
                "- For Visual Studio: Microsoft.VisualStudio.2022.Community/Professional/Enterprise`n" +
                "- Prefer Community/free editions when multiple exist`n" +
                "- Do NOT return the invalid ID shown above`n`n" +
                "Return ONLY one of:`n" +
                "- The correct winget ID (e.g., Microsoft.VisualStudio.2022.Community)`n" +
                "- NOT_AVAILABLE if the app is confirmed not in winget`n" +
                "- UNKNOWN if you cannot determine the ID"

              $body = @{
                model = "gpt-5-nano"
                instructions = "You are a winget package ID expert. Use web search to find correct winget IDs. Return ONLY the winget ID, NOT_AVAILABLE, or UNKNOWN. No explanations."
                input = $prompt
                tools = @(
                  @{
                    type = "web_search"
                  }
                )
              } | ConvertTo-Json -Depth 10

              $response = Invoke-RestMethod -Uri "https://api.openai.com/v1/responses" `
                -Method Post `
                -Headers @{
                  "Authorization" = "Bearer $apiKey"
                  "Content-Type" = "application/json"
                } `
                -Body $body `
                -TimeoutSec 120

              # Extract text from Responses API - find message in output array
              $answer = $null
              if ($response.output -and $response.output.Count -gt 0) {
                foreach ($item in $response.output) {
                  if ($item.type -eq "message" -and $item.content) {
                    foreach ($contentItem in $item.content) {
                      if ($contentItem.type -eq "output_text" -and $contentItem.text) {
                        $answer = $contentItem.text.Trim()
                        break
                      }
                    }
                  }
                  if ($answer) { break }
                }
              }

              if (-not $answer) {
                Write-Host "    Could not extract text from API response" -ForegroundColor Yellow
                Write-Host "    Response: $($response | ConvertTo-Json -Depth 5 -Compress)" -ForegroundColor Gray
                return @{ Status = "UNKNOWN"; Id = $null }
              }

              # Clean up answer - extract just the ID if there's extra text
              if ($answer -match '([A-Za-z0-9_-]+\.[A-Za-z0-9._-]+)') {
                $extractedId = $Matches[1]
                Write-Host "    API returned: $extractedId" -ForegroundColor Gray
                $answer = $extractedId
              } else {
                Write-Host "    API returned: $answer" -ForegroundColor Gray
              }

              # Validate the response format
              if ($answer -eq "NOT_AVAILABLE" -or $answer -eq "UNKNOWN" -or $answer -match "NOT_AVAILABLE|not available|UNKNOWN") {
                return @{ Status = "NOT_AVAILABLE"; Id = $null }
              }

              # Check if it looks like a valid winget ID (Publisher.Name format)
              if ($answer -match '^[A-Za-z0-9_-]+\.[A-Za-z0-9._-]+$') {
                # Verify the ID actually exists in winget
                $verifyOutput = winget show --id $answer --exact --source winget --accept-source-agreements 2>&1 | Out-String
                if ($LASTEXITCODE -eq 0 -and $verifyOutput -notmatch 'No package found') {
                  return @{ Status = "FOUND"; Id = $answer }
                } else {
                  Write-Host "    OpenAI suggested '$answer' but it doesn't exist in winget" -ForegroundColor Yellow
                  return @{ Status = "INVALID"; Id = $null }
                }
              }

              return @{ Status = "INVALID"; Id = $null }
            } catch {
              Write-Host "    OpenAI API error: $_" -ForegroundColor Red
              return $null
            }
          }

          # Load apps to validate
          $apps = Get-Content "apps-to-validate.json" | ConvertFrom-Json
          $results = @()
          $validated = 0
          $discovered = 0
          $aiDiscovered = 0
          $notInWinget = 0
          $failed = 0

          Write-Host "Processing $($apps.Count) apps in mode: $mode"
          Write-Host ""

          foreach ($app in $apps) {
            $wingetId = $app.winget_id
            $result = @{
              id = $app.id
              winget_id = $wingetId
              original_winget_id = $wingetId
              name = $app.name
              publisher = $app.publisher
              is_valid = $false
              discovered_id = $null
              match_score = 0
              discovery_method = $null
              not_in_winget = $false
              error = $null
            }

            Write-Host "[$($apps.IndexOf($app) + 1)/$($apps.Count)] Checking: $wingetId"

            try {
              # Step 1: Validate existing ID (if mode includes validation)
              if ($mode -eq 'validate' -or $mode -eq 'both') {
                # Use --exact flag to ensure precise ID matching
                # Retry up to 3 times to handle transient failures
                $retryCount = 0
                $maxRetries = 3
                $isValid = $false

                while ($retryCount -lt $maxRetries -and -not $isValid) {
                  $retryCount++
                  $showOutput = winget show --id $wingetId --exact --source winget --accept-source-agreements 2>&1 | Out-String

                  if ($LASTEXITCODE -eq 0 -and $showOutput -notmatch 'No package found') {
                    $isValid = $true
                  } elseif ($retryCount -lt $maxRetries) {
                    Write-Host "  Retry $retryCount/$maxRetries..." -ForegroundColor Gray
                    Start-Sleep -Milliseconds 1000
                  }
                }

                if ($isValid) {
                  $result.is_valid = $true
                  $validated++
                  Write-Host "  VALID" -ForegroundColor Green
                } else {
                  Write-Host "  INVALID - ID not found in winget" -ForegroundColor Yellow
                }
              }

              # Step 2: Search for correct ID (if mode includes discovery and ID is invalid)
              if ((-not $result.is_valid) -and ($mode -eq 'discover' -or $mode -eq 'both')) {
                # Extract components from existing winget ID for smarter searching
                $idParts = Get-IdComponents $wingetId
                $searchResults = @()

                # Stage 0: Try searching by exact ID first (winget show may have failed but search works)
                Write-Host "  Stage 0: Verifying existing ID via search..."
                $idSearchOutput = winget search --id $wingetId --exact --source winget --accept-source-agreements 2>&1 | Out-String
                $idSearchResults = Parse-WingetSearch $idSearchOutput
                if ($idSearchResults.Count -gt 0) {
                  # The existing ID is actually valid - mark it as such
                  $result.is_valid = $true
                  $validated++
                  Write-Host "  VALID (confirmed via search)" -ForegroundColor Green
                  $results += $result
                  Start-Sleep -Milliseconds 500
                  continue
                }

                # Stage 1: Search with cleaned app name
                $cleanedName = Clean-AppName $app.name
                Write-Host "  Stage 1: Searching for cleaned name '$cleanedName'..."
                $searchOutput = winget search --name "$cleanedName" --accept-source-agreements 2>&1 | Out-String
                $searchResults = Parse-WingetSearch $searchOutput

                # Stage 2: If no results, try app name extracted from existing winget ID
                if ($searchResults.Count -eq 0 -and $idParts) {
                  Write-Host "  Stage 2: Searching for ID component '$($idParts.AppName)'..."
                  $searchOutput = winget search --name "$($idParts.AppName)" --accept-source-agreements 2>&1 | Out-String
                  $searchResults = Parse-WingetSearch $searchOutput
                }

                # Stage 3: If still no results, try "Publisher AppName" combined search
                if ($searchResults.Count -eq 0 -and $idParts) {
                  $combinedSearch = "$($idParts.Publisher) $($idParts.AppName)"
                  Write-Host "  Stage 3: Searching for '$combinedSearch'..."
                  $searchOutput = winget search "$combinedSearch" --accept-source-agreements 2>&1 | Out-String
                  $searchResults = Parse-WingetSearch $searchOutput
                }

                # Stage 4: Last resort - broader search with original name
                if ($searchResults.Count -eq 0) {
                  Write-Host "  Stage 4: Broader search for '$($app.name)'..."
                  $searchOutput = winget search "$($app.name)" --accept-source-agreements 2>&1 | Out-String
                  $searchResults = Parse-WingetSearch $searchOutput
                }

                # Stage 4.5: Search by ID pattern to find similar IDs (e.g., Microsoft.Skype when searching by name fails)
                if ($searchResults.Count -eq 0 -and $idParts) {
                  Write-Host "  Stage 4.5: Searching by ID pattern '$($idParts.Publisher).*'..."
                  $searchOutput = winget search --id "$($idParts.Publisher)." --source winget --accept-source-agreements 2>&1 | Out-String
                  $idPatternResults = Parse-WingetSearch $searchOutput
                  # Filter to results that might match our app
                  $searchResults = $idPatternResults | Where-Object {
                    $_.Id -like "*$($idParts.AppName)*" -or $_.Name -like "*$($app.name)*"
                  }
                }

                $match = $null
                if ($searchResults.Count -gt 0) {
                  Write-Host "  Found $($searchResults.Count) potential matches"
                  $match = Get-BestMatch -AppName $app.name -Publisher $app.publisher -ExistingWingetId $wingetId -SearchResults $searchResults
                }

                if ($match) {
                  $result.discovered_id = $match.Id
                  $result.match_score = $match.Score
                  $result.discovery_method = "winget_search"
                  $discovered++
                  Write-Host "  DISCOVERED: $($match.Id) (score: $($match.Score))" -ForegroundColor Cyan
                } else {
                  # Stage 5: OpenAI with web search as final fallback
                  Write-Host "  Stage 5: Querying OpenAI with web search..." -ForegroundColor Magenta
                  $aiResult = Get-WingetIdFromOpenAI -AppName $app.name -Publisher $app.publisher -ExistingWingetId $wingetId

                  if ($aiResult -and $aiResult.Status -eq "FOUND" -and $aiResult.Id) {
                    $result.discovered_id = $aiResult.Id
                    $result.match_score = 200  # High score for AI-verified result
                    $result.discovery_method = "openai_websearch"
                    $aiDiscovered++
                    Write-Host "  DISCOVERED (AI): $($aiResult.Id)" -ForegroundColor Cyan
                  } elseif ($aiResult -and $aiResult.Status -eq "NOT_AVAILABLE") {
                    $result.error = "App not available in winget repository"
                    $result.not_in_winget = $true
                    $notInWinget++
                    Write-Host "  NOT IN WINGET - App is not available in winget repository" -ForegroundColor Red
                  } else {
                    $result.error = "Could not determine winget ID"
                    $failed++
                    Write-Host "  FAILED - Could not determine correct winget ID" -ForegroundColor Red
                  }
                }
              }
            } catch {
              $result.error = $_.ToString()
              Write-Warning "Error processing $wingetId : $_"
              $failed++
            }

            $results += $result

            # Rate limiting to avoid overwhelming winget/API
            Start-Sleep -Milliseconds 500
          }

          Write-Host ""
          Write-Host "=== Summary ===" -ForegroundColor Cyan
          Write-Host "Validated (existing ID works): $validated"
          Write-Host "Discovered (winget search): $discovered"
          Write-Host "Discovered (AI web search): $aiDiscovered"
          Write-Host "Not in winget: $notInWinget"
          Write-Host "Failed (unknown): $failed"

          # Save results
          $results | ConvertTo-Json -Depth 10 | Out-File "validation-results.json" -Encoding UTF8

          # Set outputs
          $totalDiscovered = $discovered + $aiDiscovered
          echo "validated=$validated" >> $env:GITHUB_OUTPUT
          echo "discovered=$totalDiscovered" >> $env:GITHUB_OUTPUT
          echo "ai_discovered=$aiDiscovered" >> $env:GITHUB_OUTPUT
          echo "not_in_winget=$notInWinget" >> $env:GITHUB_OUTPUT
          echo "failed=$failed" >> $env:GITHUB_OUTPUT

      - name: Update Supabase with results
        if: steps.fetch.outputs.app_count != '0'
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        shell: bash
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;

          if (!supabaseUrl || !supabaseKey) {
            console.error('Supabase credentials not configured');
            process.exit(1);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function updateResults() {
            const results = JSON.parse(fs.readFileSync('validation-results.json', 'utf8'));

            let updated = 0;
            let corrected = 0;
            let errors = 0;
            const validatedIds = [];

            for (const result of results) {
              try {
                if (result.is_valid) {
                  // Mark as verified
                  const { error } = await supabase
                    .from('curated_apps')
                    .update({
                      is_winget_verified: true,
                      winget_verified_at: new Date().toISOString(),
                      updated_at: new Date().toISOString()
                    })
                    .eq('id', result.id);

                  if (error) {
                    console.error(`Failed to update ${result.winget_id}:`, error.message);
                    errors++;
                  } else {
                    updated++;
                    validatedIds.push(result.winget_id);
                  }
                } else if (result.discovered_id) {
                  // Update with corrected ID and mark as verified
                  const { error } = await supabase
                    .from('curated_apps')
                    .update({
                      winget_id: result.discovered_id,
                      is_winget_verified: true,
                      winget_verified_at: new Date().toISOString(),
                      updated_at: new Date().toISOString()
                    })
                    .eq('id', result.id);

                  if (error) {
                    console.error(`Failed to correct ${result.winget_id} -> ${result.discovered_id}:`, error.message);
                    errors++;
                  } else {
                    corrected++;
                    validatedIds.push(result.discovered_id);
                    console.log(`Corrected: ${result.original_winget_id} -> ${result.discovered_id}`);
                  }
                }
              } catch (e) {
                console.error(`Error updating ${result.winget_id}:`, e.message);
                errors++;
              }
            }

            // Update sync status
            await supabase.from('curated_sync_status').upsert({
              id: 'validate-winget-ids',
              last_run_completed_at: new Date().toISOString(),
              last_run_status: errors > 0 && updated + corrected === 0 ? 'failed' : 'success',
              items_processed: updated + corrected,
              error_message: errors > 0 ? `${errors} updates failed` : null,
              metadata: {
                validated: updated,
                corrected: corrected,
                errors: errors,
                total_processed: results.length
              },
              updated_at: new Date().toISOString()
            });

            console.log(`\nDatabase updates complete:`);
            console.log(`  - Validated: ${updated}`);
            console.log(`  - Corrected: ${corrected}`);
            console.log(`  - Errors: ${errors}`);

            // Save validated IDs for triggering sync-manifests
            fs.writeFileSync('validated-ids.json', JSON.stringify(validatedIds));
          }

          updateResults().catch(err => {
            console.error('Update failed:', err);
            process.exit(1);
          });
          EOF

      - name: Trigger sync-manifests workflow
        if: success() && steps.fetch.outputs.app_count != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          if [ -f validated-ids.json ]; then
            VALIDATED_COUNT=$(jq 'length' validated-ids.json)

            if [ "$VALIDATED_COUNT" -gt 0 ]; then
              # Get comma-separated list of validated IDs (limit to first 50 for workflow input)
              VALIDATED_IDS=$(jq -r '.[0:50] | join(",")' validated-ids.json)

              echo "Triggering sync-manifests for $VALIDATED_COUNT validated apps..."

              gh workflow run sync-manifests.yml \
                -f app_ids="$VALIDATED_IDS" \
                -f limit="50" || echo "Failed to trigger sync-manifests workflow"
            else
              echo "No validated IDs to sync"
            fi
          fi

      - name: Create summary
        if: always()
        shell: bash
        run: |
          echo "## Winget ID Validation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f validation-results.json ]; then
            TOTAL=$(jq 'length' validation-results.json)
            VALID=$(jq '[.[] | select(.is_valid == true)] | length' validation-results.json)
            DISCOVERED_WINGET=$(jq '[.[] | select(.discovered_id != null and .discovery_method == "winget_search")] | length' validation-results.json)
            DISCOVERED_AI=$(jq '[.[] | select(.discovered_id != null and .discovery_method == "openai_websearch")] | length' validation-results.json)
            NOT_IN_WINGET=$(jq '[.[] | select(.not_in_winget == true)] | length' validation-results.json)
            FAILED=$(jq '[.[] | select(.is_valid == false and .discovered_id == null and .not_in_winget != true)] | length' validation-results.json)

            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Total Processed | $TOTAL |" >> $GITHUB_STEP_SUMMARY
            echo "| Valid (existing ID works) | $VALID |" >> $GITHUB_STEP_SUMMARY
            echo "| Discovered (winget search) | $DISCOVERED_WINGET |" >> $GITHUB_STEP_SUMMARY
            echo "| Discovered (AI web search) | $DISCOVERED_AI |" >> $GITHUB_STEP_SUMMARY
            echo "| Not available in winget | $NOT_IN_WINGET |" >> $GITHUB_STEP_SUMMARY
            echo "| Failed (unknown) | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$DISCOVERED_WINGET" -gt 0 ] || [ "$DISCOVERED_AI" -gt 0 ]; then
              echo "### Corrected IDs" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| Original ID | Corrected ID | Method | Score |" >> $GITHUB_STEP_SUMMARY
              echo "|-------------|--------------|--------|-------|" >> $GITHUB_STEP_SUMMARY
              jq -r '.[] | select(.discovered_id != null) | "| \(.original_winget_id) | \(.discovered_id) | \(.discovery_method // "unknown") | \(.match_score) |"' validation-results.json >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$NOT_IN_WINGET" -gt 0 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Apps Not Available in Winget" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| App Name | Original ID |" >> $GITHUB_STEP_SUMMARY
              echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
              jq -r '.[] | select(.not_in_winget == true) | "| \(.name) | \(.original_winget_id) |"' validation-results.json >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No validation results found" >> $GITHUB_STEP_SUMMARY
          fi
